{"version":3,"sources":["src/common.speech/SynthesisAdapterBase.ts"],"names":[],"mappings":"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","file":"SynthesisAdapterBase.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport {\n    ArgumentNullError,\n    ConnectionClosedEvent,\n    ConnectionEvent,\n    ConnectionMessage,\n    ConnectionState,\n    createNoDashGuid,\n    EventSource,\n    IAudioDestination,\n    IConnection,\n    IDisposable,\n    MessageType,\n    ServiceEvent,\n} from \"../common/Exports\";\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\nimport {\n    CancellationErrorCode,\n    CancellationReason,\n    PropertyCollection,\n    PropertyId,\n    ResultReason,\n    SpeechSynthesisBookmarkEventArgs,\n    SpeechSynthesisEventArgs,\n    SpeechSynthesisResult,\n    SpeechSynthesisVisemeEventArgs,\n    SpeechSynthesisWordBoundaryEventArgs,\n    SpeechSynthesizer,\n} from \"../sdk/Exports\";\nimport {\n    AgentConfig,\n    CancellationErrorCodePropertyName,\n    ISynthesisConnectionFactory,\n    MetadataType,\n    SynthesisAudioMetadata,\n    SynthesisContext,\n    SynthesisTurn,\n    SynthesizerConfig\n} from \"./Exports\";\nimport { AuthInfo, IAuthentication } from \"./IAuthentication\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\n\nexport class SynthesisAdapterBase implements IDisposable {\n    protected privSynthesisTurn: SynthesisTurn;\n    protected privConnectionId: string;\n    protected privSynthesizerConfig: SynthesizerConfig;\n    protected privSpeechSynthesizer: SpeechSynthesizer;\n    protected privSuccessCallback: (e: SpeechSynthesisResult) => void;\n    protected privErrorCallback: (e: string) => void;\n\n    public get synthesisContext(): SynthesisContext {\n        return this.privSynthesisContext;\n    }\n\n    public get agentConfig(): AgentConfig {\n        return this.privAgentConfig;\n    }\n\n    public get connectionEvents(): EventSource<ConnectionEvent> {\n        return this.privConnectionEvents;\n    }\n\n    public get serviceEvents(): EventSource<ServiceEvent> {\n        return this.privServiceEvents;\n    }\n\n    protected speakOverride: (ssml: string, requestId: string, sc: (e: SpeechSynthesisResult) => void, ec: (e: string) => void) => void = undefined;\n\n    // Called when telemetry data is sent to the service.\n    // Used for testing Telemetry capture.\n    public static telemetryData: (json: string) => void;\n    public static telemetryDataEnabled: boolean = true;\n\n    public set activityTemplate(messagePayload: string) {\n        this.privActivityTemplate = messagePayload;\n    }\n    public get activityTemplate(): string {\n        return this.privActivityTemplate;\n    }\n\n    protected receiveMessageOverride: () => void = undefined;\n\n    protected connectImplOverride: (isUnAuthorized: boolean) => void = undefined;\n\n    protected configConnectionOverride: (connection: IConnection) => Promise<IConnection> = undefined;\n\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\n        this.privAudioOutputFormat = format;\n        this.privSynthesisTurn.audioOutputFormat = format;\n        if (this.privSessionAudioDestination !== undefined) {\n            this.privSessionAudioDestination.format = format;\n        }\n        if (this.synthesisContext !== undefined) {\n            this.synthesisContext.audioOutputFormat = format;\n        }\n    }\n    private privAuthentication: IAuthentication;\n    private privConnectionFactory: ISynthesisConnectionFactory;\n\n    // A promise for a configured connection.\n    // Do not consume directly, call fetchConnection instead.\n    private privConnectionConfigurationPromise: Promise<IConnection> = undefined;\n\n    // A promise for a connection, but one that has not had the speech context sent yet.\n    // Do not consume directly, call fetchConnection instead.\n    private privConnectionPromise: Promise<IConnection>;\n    private privAuthFetchEventId: string;\n    private privIsDisposed: boolean;\n    private privConnectionEvents: EventSource<ConnectionEvent>;\n    private privServiceEvents: EventSource<ServiceEvent>;\n    private privSynthesisContext: SynthesisContext;\n    private privAgentConfig: AgentConfig;\n    private privActivityTemplate: string;\n    private privAudioOutputFormat: AudioOutputFormatImpl;\n    private privSessionAudioDestination: IAudioDestination;\n\n    public constructor(\n        authentication: IAuthentication,\n        connectionFactory: ISynthesisConnectionFactory,\n        synthesizerConfig: SynthesizerConfig,\n        speechSynthesizer: SpeechSynthesizer,\n        audioDestination: IAudioDestination) {\n\n        if (!authentication) {\n            throw new ArgumentNullError(\"authentication\");\n        }\n\n        if (!connectionFactory) {\n            throw new ArgumentNullError(\"connectionFactory\");\n        }\n\n        if (!synthesizerConfig) {\n            throw new ArgumentNullError(\"synthesizerConfig\");\n        }\n\n        this.privAuthentication = authentication;\n        this.privConnectionFactory = connectionFactory;\n        this.privSynthesizerConfig = synthesizerConfig;\n        this.privIsDisposed = false;\n        this.privSpeechSynthesizer = speechSynthesizer;\n        this.privSessionAudioDestination = audioDestination;\n        this.privSynthesisTurn = new SynthesisTurn();\n        this.privConnectionEvents = new EventSource<ConnectionEvent>();\n        this.privServiceEvents = new EventSource<ServiceEvent>();\n        this.privSynthesisContext = new SynthesisContext(this.privSpeechSynthesizer);\n        this.privAgentConfig = new AgentConfig();\n\n        this.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\n                const connectionClosedEvent = connectionEvent as ConnectionClosedEvent;\n                if (connectionClosedEvent.statusCode !== 1000) {\n                    this.cancelSynthesisLocal(CancellationReason.Error,\n                        connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure,\n                        `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);\n                }\n            }\n        });\n    }\n\n    public static addHeader(audio: ArrayBuffer, format: AudioOutputFormatImpl): ArrayBuffer {\n        if (!format.hasHeader) {\n            return audio;\n        }\n        format.updateHeader(audio.byteLength);\n        const tmp = new Uint8Array(audio.byteLength + format.header.byteLength);\n        tmp.set(new Uint8Array(format.header), 0);\n        tmp.set(new Uint8Array(audio), format.header.byteLength);\n        return tmp.buffer;\n    }\n\n    public isDisposed(): boolean {\n        return this.privIsDisposed;\n    }\n\n    public async dispose(reason?: string): Promise<void> {\n        this.privIsDisposed = true;\n        if (this.privSessionAudioDestination !== undefined) {\n            this.privSessionAudioDestination.close();\n        }\n        if (this.privConnectionConfigurationPromise !== undefined) {\n            const connection: IConnection = await this.privConnectionConfigurationPromise;\n            await connection.dispose(reason);\n        }\n    }\n\n    public async connect(): Promise<void> {\n        await this.connectImpl();\n    }\n\n    public async sendNetworkMessage(path: string, payload: string | ArrayBuffer): Promise<void> {\n        const type: MessageType = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\n        const contentType: string = typeof payload === \"string\" ? \"application/json\" : \"\";\n\n        const connection: IConnection = await this.fetchConnection();\n        return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\n    }\n\n    public async Speak(\n        text: string,\n        isSSML: boolean,\n        requestId: string,\n        successCallback: (e: SpeechSynthesisResult) => void,\n        errorCallBack: (e: string) => void,\n        audioDestination: IAudioDestination,\n    ): Promise<void> {\n\n        let ssml: string;\n\n        if (isSSML) {\n            ssml = text;\n        } else {\n            ssml = this.privSpeechSynthesizer.buildSsml(text);\n        }\n\n        if (this.speakOverride !== undefined) {\n            return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\n        }\n\n        this.privSuccessCallback = successCallback;\n        this.privErrorCallback = errorCallBack;\n\n        this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\n\n        try {\n            await this.connectImpl();\n            const connection: IConnection = await this.fetchConnection();\n            await this.sendSynthesisContext(connection);\n            await this.sendSsmlMessage(connection, ssml, requestId);\n            const synthesisStartEventArgs: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\n                new SpeechSynthesisResult(\n                    requestId,\n                    ResultReason.SynthesizingAudioStarted,\n                )\n            );\n\n            if (!!this.privSpeechSynthesizer.synthesisStarted) {\n                this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);\n            }\n\n            void this.receiveMessage();\n        } catch (e) {\n            this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e as string);\n            return Promise.reject(e);\n        }\n    }\n\n    // Cancels synthesis.\n    protected cancelSynthesis(\n        requestId: string,\n        cancellationReason: CancellationReason,\n        errorCode: CancellationErrorCode,\n        error: string): void {\n        const properties: PropertyCollection = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n        const result: SpeechSynthesisResult = new SpeechSynthesisResult(\n            requestId,\n            ResultReason.Canceled,\n            undefined,\n            error,\n            properties\n        );\n\n        if (!!this.privSpeechSynthesizer.SynthesisCanceled) {\n            const cancelEvent: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(result);\n            try {\n                this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);\n                /* eslint-disable no-empty */\n            } catch { }\n        }\n\n        if (!!this.privSuccessCallback) {\n            try {\n                this.privSuccessCallback(result);\n                /* eslint-disable no-empty */\n            } catch { }\n        }\n    }\n\n    // Cancels synthesis.\n    protected cancelSynthesisLocal(\n        cancellationReason: CancellationReason,\n        errorCode: CancellationErrorCode,\n        error: string): void {\n\n        if (!!this.privSynthesisTurn.isSynthesizing) {\n            this.privSynthesisTurn.onStopSynthesizing();\n\n            this.cancelSynthesis(\n                this.privSynthesisTurn.requestId,\n                cancellationReason,\n                errorCode,\n                error);\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    protected processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): boolean {\n        return true;\n    }\n\n    protected async receiveMessage(): Promise<void> {\n        try {\n            const connection: IConnection = await this.fetchConnection();\n            const message: ConnectionMessage = await connection.read();\n\n            if (this.receiveMessageOverride !== undefined) {\n                return this.receiveMessageOverride();\n            }\n            if (this.privIsDisposed) {\n                // We're done.\n                return;\n            }\n\n            // indicates we are draining the queue and it came with no message;\n            if (!message) {\n                if (!this.privSynthesisTurn.isSynthesizing) {\n                    return;\n                } else {\n                    return this.receiveMessage();\n                }\n            }\n\n\n            const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n\n            if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\n                switch (connectionMessage.path.toLowerCase()) {\n                    case \"turn.start\":\n                        this.privSynthesisTurn.onServiceTurnStartResponse();\n                        break;\n                    case \"response\":\n                        this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\n                        break;\n                    case \"audio\":\n                        if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase()\n                            && !!connectionMessage.binaryBody) {\n                            this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\n                            if (!!this.privSpeechSynthesizer.synthesizing) {\n                                try {\n                                    const audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat);\n                                    const ev: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\n                                        new SpeechSynthesisResult(\n                                            this.privSynthesisTurn.requestId,\n                                            ResultReason.SynthesizingAudio,\n                                            audioWithHeader));\n                                    this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);\n                                } catch (error) {\n                                    // Not going to let errors in the event handler\n                                    // trip things up.\n                                }\n                            }\n                            if (this.privSessionAudioDestination !== undefined) {\n                                this.privSessionAudioDestination.write(connectionMessage.binaryBody);\n                            }\n                        }\n                        break;\n                    case \"audio.metadata\":\n                        const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\n                        for (const metadata of metadataList) {\n                            switch (metadata.Type) {\n                                case MetadataType.WordBoundary:\n                                case MetadataType.SentenceBoundary:\n                                    this.privSynthesisTurn.onTextBoundaryEvent(metadata);\n\n                                    const wordBoundaryEventArgs: SpeechSynthesisWordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(\n                                        metadata.Data.Offset,\n                                        metadata.Data.Duration,\n                                        metadata.Data.text.Text,\n                                        metadata.Data.text.Length,\n                                        metadata.Type === MetadataType.WordBoundary\n                                            ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset,\n                                        metadata.Data.text.BoundaryType);\n\n                                    if (!!this.privSpeechSynthesizer.wordBoundary) {\n                                        try {\n                                            this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);\n                                        } catch (error) {\n                                            // Not going to let errors in the event handler\n                                            // trip things up.\n                                        }\n                                    }\n                                    break;\n                                case MetadataType.Bookmark:\n                                    const bookmarkEventArgs: SpeechSynthesisBookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(\n                                        metadata.Data.Offset,\n                                        metadata.Data.Bookmark);\n\n                                    if (!!this.privSpeechSynthesizer.bookmarkReached) {\n                                        try {\n                                            this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);\n                                        } catch (error) {\n                                            // Not going to let errors in the event handler\n                                            // trip things up.\n                                        }\n                                    }\n                                    break;\n                                case MetadataType.Viseme:\n                                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\n                                    if (metadata.Data.IsLastAnimation) {\n                                        const visemeEventArgs: SpeechSynthesisVisemeEventArgs = new SpeechSynthesisVisemeEventArgs(\n                                            metadata.Data.Offset,\n                                            metadata.Data.VisemeId,\n                                            this.privSynthesisTurn.getAndClearVisemeAnimation());\n\n                                        if (!!this.privSpeechSynthesizer.visemeReceived) {\n                                            try {\n                                                this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);\n                                            } catch (error) {\n                                                // Not going to let errors in the event handler\n                                                // trip things up.\n                                            }\n                                        }\n                                    }\n                                    break;\n                                case MetadataType.SessionEnd:\n                                    this.privSynthesisTurn.onSessionEnd(metadata);\n                                    break;\n                            }\n                        }\n                        break;\n                    case \"turn.end\":\n                        this.privSynthesisTurn.onServiceTurnEndResponse();\n                        let result: SpeechSynthesisResult;\n                        try {\n                            const audioBuffer: ArrayBuffer = await this.privSynthesisTurn.getAllReceivedAudioWithHeader();\n                            result = new SpeechSynthesisResult(\n                                this.privSynthesisTurn.requestId,\n                                ResultReason.SynthesizingAudioCompleted,\n                                audioBuffer,\n                                undefined,\n                                undefined,\n                                this.privSynthesisTurn.audioDuration\n                            );\n                            if (!!this.privSuccessCallback) {\n                                this.privSuccessCallback(result);\n                            }\n                        } catch (error) {\n                            if (!!this.privErrorCallback) {\n                                this.privErrorCallback(error as string);\n                            }\n                        }\n                        if (this.privSpeechSynthesizer.synthesisCompleted) {\n                            try {\n                                this.privSpeechSynthesizer.synthesisCompleted(\n                                    this.privSpeechSynthesizer,\n                                    new SpeechSynthesisEventArgs(result)\n                                );\n                            } catch (e) {\n                                // Not going to let errors in the event handler\n                                // trip things up.\n                            }\n                        }\n                        break;\n\n                    default:\n\n                        if (!this.processTypeSpecificMessages(connectionMessage)) {\n                            // here are some messages that the derived class has not processed, dispatch them to connect class\n                            if (!!this.privServiceEvents) {\n                                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                            }\n                        }\n\n                }\n            }\n\n            return this.receiveMessage();\n\n        } catch (e) {\n            // TODO: What goes here?\n        }\n    }\n\n    protected sendSynthesisContext(connection: IConnection): Promise<void> {\n        const synthesisContextJson = this.synthesisContext.toJSON();\n\n        if (synthesisContextJson) {\n            return connection.send(new SpeechConnectionMessage(\n                MessageType.Text,\n                \"synthesis.context\",\n                this.privSynthesisTurn.requestId,\n                \"application/json\",\n                synthesisContextJson));\n        }\n        return;\n    }\n\n    protected connectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\n        if (this.privConnectionPromise != null) {\n            return this.privConnectionPromise.then((connection: IConnection): Promise<IConnection> => {\n                if (connection.state() === ConnectionState.Disconnected) {\n                    this.privConnectionId = null;\n                    this.privConnectionPromise = null;\n                    return this.connectImpl();\n                }\n                return this.privConnectionPromise;\n            }, (): Promise<IConnection> => {\n                this.privConnectionId = null;\n                this.privConnectionPromise = null;\n                return this.connectImpl();\n            });\n        }\n        this.privAuthFetchEventId = createNoDashGuid();\n        this.privConnectionId = createNoDashGuid();\n\n        this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);\n\n        const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\n\n        this.privConnectionPromise = authPromise.then(async (result: AuthInfo): Promise<IConnection> => {\n            this.privSynthesisTurn.onAuthCompleted(false);\n\n            const connection: IConnection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);\n\n            // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n            // it'll stop sending events.\n            connection.events.attach((event: ConnectionEvent): void => {\n                this.connectionEvents.onEvent(event);\n            });\n            const response = await connection.open();\n            if (response.statusCode === 200) {\n                this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n                return Promise.resolve(connection);\n            } else if (response.statusCode === 403 && !isUnAuthorized) {\n                return this.connectImpl(true);\n            } else {\n                this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n                return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\n            }\n        }, (error: string): Promise<IConnection> => {\n            this.privSynthesisTurn.onAuthCompleted(true);\n            throw new Error(error);\n        });\n\n        // Attach an empty handler to allow the promise to run in the background while\n        // other startup events happen. It'll eventually be awaited on.\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        this.privConnectionPromise.catch((): void => { });\n\n        return this.privConnectionPromise;\n    }\n    protected sendSpeechServiceConfig(connection: IConnection, SpeechServiceConfigJson: string): Promise<void> {\n        if (SpeechServiceConfigJson) {\n            return connection.send(new SpeechConnectionMessage(\n                MessageType.Text,\n                \"speech.config\",\n                this.privSynthesisTurn.requestId,\n                \"application/json\",\n                SpeechServiceConfigJson));\n        }\n    }\n\n    protected sendSsmlMessage(connection: IConnection, ssml: string, requestId: string): Promise<void> {\n        return connection.send(new SpeechConnectionMessage(\n            MessageType.Text,\n            \"ssml\",\n            requestId,\n            \"application/ssml+xml\",\n            ssml));\n    }\n\n    private async fetchConnection(): Promise<IConnection> {\n        if (this.privConnectionConfigurationPromise !== undefined) {\n            return this.privConnectionConfigurationPromise.then((connection: IConnection): Promise<IConnection> => {\n                if (connection.state() === ConnectionState.Disconnected) {\n                    this.privConnectionId = null;\n                    this.privConnectionConfigurationPromise = undefined;\n                    return this.fetchConnection();\n                }\n                return this.privConnectionConfigurationPromise;\n            }, (): Promise<IConnection> => {\n                this.privConnectionId = null;\n                this.privConnectionConfigurationPromise = undefined;\n                return this.fetchConnection();\n            });\n        }\n        this.privConnectionConfigurationPromise = this.configureConnection();\n        return await this.privConnectionConfigurationPromise;\n    }\n\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\n    private async configureConnection(): Promise<IConnection> {\n        const connection: IConnection = await this.connectImpl();\n        if (this.configConnectionOverride !== undefined) {\n            return this.configConnectionOverride(connection);\n        }\n        await this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\n        return connection;\n    }\n}\n"]}