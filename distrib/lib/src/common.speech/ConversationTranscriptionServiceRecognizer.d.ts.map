{"version":3,"sources":["src/common.speech/ConversationTranscriptionServiceRecognizer.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACjD,OAAO,EACH,qBAAqB,EACrB,kBAAkB,EAQlB,uBAAuB,EAC1B,MAAM,gBAAgB,CAAC;AACxB,OAAO,EAMH,qBAAqB,EAGxB,MAAM,WAAW,CAAC;AACnB,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AACpD,OAAO,EAAE,kBAAkB,EAAE,MAAM,sBAAsB,CAAC;AAC1D,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AACtD,OAAO,EAAE,uBAAuB,EAAE,MAAM,oCAAoC,CAAC;AAI7E,qBAAa,0CAA2C,SAAQ,qBAAqB;IAEjF,OAAO,CAAC,2BAA2B,CAA0B;gBAGzD,cAAc,EAAE,eAAe,EAC/B,iBAAiB,EAAE,kBAAkB,EACrC,WAAW,EAAE,YAAY,EACzB,gBAAgB,EAAE,gBAAgB,EAClC,uBAAuB,EAAE,uBAAuB;IAMpD,SAAS,CAAC,yBAAyB,IAAI,IAAI;cAY3B,2BAA2B,CAAC,iBAAiB,EAAE,uBAAuB,GAAG,OAAO,CAAC,OAAO,CAAC;IAgHzG,SAAS,CAAC,iBAAiB,CACvB,SAAS,EAAE,MAAM,EACjB,SAAS,EAAE,MAAM,EACjB,kBAAkB,EAAE,kBAAkB,EACtC,SAAS,EAAE,qBAAqB,EAChC,KAAK,EAAE,MAAM,GAAG,IAAI;CAkB3B","file":"ConversationTranscriptionServiceRecognizer.d.ts","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport { IAudioSource } from \"../common/Exports\";\nimport {\n    CancellationErrorCode,\n    CancellationReason,\n    OutputFormat,\n    PropertyCollection,\n    PropertyId,\n    ResultReason,\n    ConversationTranscriptionCanceledEventArgs,\n    ConversationTranscriptionEventArgs,\n    ConversationTranscriptionResult,\n    ConversationTranscriber,\n} from \"../sdk/Exports\";\nimport {\n    CancellationErrorCodePropertyName,\n    DetailedSpeechPhrase,\n    EnumTranslation,\n    OutputFormatPropertyName,\n    RecognitionStatus,\n    ServiceRecognizerBase,\n    SimpleSpeechPhrase,\n    SpeechHypothesis,\n} from \"./Exports\";\nimport { IAuthentication } from \"./IAuthentication\";\nimport { IConnectionFactory } from \"./IConnectionFactory\";\nimport { RecognizerConfig } from \"./RecognizerConfig\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nimport { PhraseDetection, SpeakerDiarization } from \"./ServiceRecognizerBase\";\n\n// eslint-disable-next-line max-classes-per-file\nexport class ConversationTranscriptionServiceRecognizer extends ServiceRecognizerBase {\n\n    private privConversationTranscriber: ConversationTranscriber;\n\n    public constructor(\n        authentication: IAuthentication,\n        connectionFactory: IConnectionFactory,\n        audioSource: IAudioSource,\n        recognizerConfig: RecognizerConfig,\n        conversationTranscriber: ConversationTranscriber) {\n        super(authentication, connectionFactory, audioSource, recognizerConfig, conversationTranscriber);\n        this.privConversationTranscriber = conversationTranscriber;\n        this.setSpeakerDiarizationJson();\n    }\n\n    protected setSpeakerDiarizationJson(): void {\n        if (this.privEnableSpeakerId) {\n            const phraseDetection = this.privSpeechContext.getSection(\"phraseDetection\") as PhraseDetection;\n            const speakerDiarization: SpeakerDiarization = {};\n            speakerDiarization.mode = \"Anonymous\";\n            speakerDiarization.audioSessionId = this.privDiarizationSessionId;\n            speakerDiarization.audioOffsetMs = 0;\n            phraseDetection.speakerDiarization = speakerDiarization;\n            this.privSpeechContext.setSection(\"phraseDetection\", phraseDetection);\n        }\n    }\n\n    protected async processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\n\n        let result: ConversationTranscriptionResult;\n        const resultProps: PropertyCollection = new PropertyCollection();\n        resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n        let processed: boolean = false;\n\n        switch (connectionMessage.path.toLowerCase()) {\n            case \"speech.hypothesis\":\n            case \"speech.fragment\":\n                const hypothesis: SpeechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\n                const offset: number = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n\n                result = new ConversationTranscriptionResult(\n                    this.privRequestSession.requestId,\n                    ResultReason.RecognizingSpeech,\n                    hypothesis.Text,\n                    hypothesis.Duration,\n                    offset,\n                    hypothesis.Language,\n                    hypothesis.LanguageDetectionConfidence,\n                    undefined, // Speaker Id\n                    undefined,\n                    connectionMessage.textBody,\n                    resultProps);\n\n                this.privRequestSession.onHypothesis(offset);\n\n                const ev = new ConversationTranscriptionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\n\n                if (!!this.privConversationTranscriber.transcribing) {\n                    try {\n                        this.privConversationTranscriber.transcribing(this.privConversationTranscriber, ev);\n                        /* eslint-disable no-empty */\n                    } catch (error) {\n                        // Not going to let errors in the event handler\n                        // trip things up.\n                    }\n                }\n                processed = true;\n                break;\n            case \"speech.phrase\":\n                const simple: SimpleSpeechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n                const resultReason: ResultReason = EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);\n\n                this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);\n\n                if (ResultReason.Canceled === resultReason) {\n                    const cancelReason: CancellationReason = EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);\n                    const cancellationErrorCode: CancellationErrorCode = EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);\n\n                    await this.cancelRecognitionLocal(\n                        cancelReason,\n                        cancellationErrorCode,\n                        EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));\n\n                } else {\n                    if (!(this.privRequestSession.isSpeechEnded && resultReason === ResultReason.NoMatch && simple.RecognitionStatus !== RecognitionStatus.InitialSilenceTimeout)) {\n                        if (this.privRecognizerConfig.parameters.getProperty(OutputFormatPropertyName) === OutputFormat[OutputFormat.Simple]) {\n                            result = new ConversationTranscriptionResult(\n                                this.privRequestSession.requestId,\n                                resultReason,\n                                simple.DisplayText,\n                                simple.Duration,\n                                simple.Offset + this.privRequestSession.currentTurnAudioOffset,\n                                simple.Language,\n                                simple.LanguageDetectionConfidence,\n                                simple.SpeakerId,\n                                undefined,\n                                connectionMessage.textBody,\n                                resultProps);\n                        } else {\n                            const detailed: DetailedSpeechPhrase = DetailedSpeechPhrase.fromJSON(connectionMessage.textBody);\n                            const totalOffset: number = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;\n                            const offsetCorrectedJson: string = detailed.getJsonWithCorrectedOffsets(totalOffset);\n\n                            result = new ConversationTranscriptionResult(\n                                this.privRequestSession.requestId,\n                                resultReason,\n                                detailed.RecognitionStatus === RecognitionStatus.Success ? detailed.NBest[0].Display : undefined,\n                                detailed.Duration,\n                                totalOffset,\n                                detailed.Language,\n                                detailed.LanguageDetectionConfidence,\n                                simple.SpeakerId,\n                                undefined,\n                                offsetCorrectedJson,\n                                resultProps);\n                        }\n\n                        const event: ConversationTranscriptionEventArgs = new ConversationTranscriptionEventArgs(result, result.offset, this.privRequestSession.sessionId);\n\n                        if (!!this.privConversationTranscriber.transcribed) {\n                            try {\n                                this.privConversationTranscriber.transcribed(this.privConversationTranscriber, event);\n                                /* eslint-disable no-empty */\n                            } catch (error) {\n                                // Not going to let errors in the event handler\n                                // trip things up.\n                            }\n                        }\n                    }\n                }\n                processed = true;\n                break;\n            default:\n                break;\n        }\n        return processed;\n    }\n\n    // Cancels recognition.\n    protected cancelRecognition(\n        sessionId: string,\n        requestId: string,\n        cancellationReason: CancellationReason,\n        errorCode: CancellationErrorCode,\n        error: string): void {\n\n        const properties: PropertyCollection = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n\n        if (!!this.privConversationTranscriber.canceled) {\n            const cancelEvent: ConversationTranscriptionCanceledEventArgs = new ConversationTranscriptionCanceledEventArgs(\n                cancellationReason,\n                error,\n                errorCode,\n                undefined,\n                sessionId);\n            try {\n                this.privConversationTranscriber.canceled(this.privConversationTranscriber, cancelEvent);\n                /* eslint-disable no-empty */\n            } catch { }\n        }\n    }\n}\n"]}