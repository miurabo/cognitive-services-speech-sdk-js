{"version":3,"sources":["src/common.speech/WebsocketMessageFormatter.ts"],"names":[],"mappings":"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","file":"WebsocketMessageFormatter.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport {\n    ConnectionMessage,\n    Deferred,\n    IStringDictionary,\n    IWebsocketMessageFormatter,\n    MessageType,\n    RawWebsocketMessage,\n} from \"../common/Exports\";\n\nconst CRLF: string = \"\\r\\n\";\n\nexport class WebsocketMessageFormatter implements IWebsocketMessageFormatter {\n\n    public toConnectionMessage(message: RawWebsocketMessage): Promise<ConnectionMessage> {\n        const deferral = new Deferred<ConnectionMessage>();\n\n        try {\n            if (message.messageType === MessageType.Text) {\n                const textMessage: string = message.textContent;\n                let headers: IStringDictionary<string> = {};\n                let body: string = null;\n\n                if (textMessage) {\n                    const headerBodySplit = textMessage.split(\"\\r\\n\\r\\n\");\n                    if (headerBodySplit && headerBodySplit.length > 0) {\n                        headers = this.parseHeaders(headerBodySplit[0]);\n                        if (headerBodySplit.length > 1) {\n                            body = headerBodySplit[1];\n                        }\n                    }\n                }\n\n                deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));\n            } else if (message.messageType === MessageType.Binary) {\n                const binaryMessage: ArrayBuffer = message.binaryContent;\n                let headers: IStringDictionary<string> = {};\n                let body: ArrayBuffer = null;\n\n                if (!binaryMessage || binaryMessage.byteLength < 2) {\n                    throw new Error(\"Invalid binary message format. Header length missing.\");\n                }\n\n                const dataView = new DataView(binaryMessage);\n                const headerLength = dataView.getInt16(0);\n\n                if (binaryMessage.byteLength < headerLength + 2) {\n                    throw new Error(\"Invalid binary message format. Header content missing.\");\n                }\n\n                let headersString = \"\";\n                for (let i = 0; i < headerLength; i++) {\n                    headersString += String.fromCharCode((dataView).getInt8(i + 2));\n                }\n\n                headers = this.parseHeaders(headersString);\n\n                if (binaryMessage.byteLength > headerLength + 2) {\n                    body = binaryMessage.slice(2 + headerLength);\n                }\n\n                deferral.resolve(new ConnectionMessage(message.messageType, body, headers, message.id));\n            }\n        } catch (e) {\n            deferral.reject(`Error formatting the message. Error: ${e as string}`);\n        }\n\n        return deferral.promise;\n    }\n\n    public fromConnectionMessage(message: ConnectionMessage): Promise<RawWebsocketMessage> {\n        const deferral = new Deferred<RawWebsocketMessage>();\n\n        try {\n            if (message.messageType === MessageType.Text) {\n                const payload = `${this.makeHeaders(message)}${CRLF}${message.textBody ? message.textBody : \"\"}`;\n\n                deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\n\n            } else if (message.messageType === MessageType.Binary) {\n                const headersString = this.makeHeaders(message);\n                const content = message.binaryBody;\n\n                const headerBuffer = this.stringToArrayBuffer(headersString);\n                const headerInt8Array = new Int8Array(headerBuffer);\n                const headerLength = headerInt8Array.byteLength;\n\n                const payloadInt8Array = new Int8Array(2 + headerLength + (content ? content.byteLength : 0));\n                payloadInt8Array[0] = ((headerLength >> 8) & 0xff);\n                payloadInt8Array[1] = headerLength & 0xff;\n                payloadInt8Array.set(headerInt8Array, 2);\n\n                if (content) {\n                    const bodyInt8Array = new Int8Array(content);\n                    payloadInt8Array.set(bodyInt8Array, 2 + headerLength);\n                }\n\n                const payload: ArrayBuffer = payloadInt8Array.buffer;\n\n                deferral.resolve(new RawWebsocketMessage(MessageType.Binary, payload, message.id));\n            }\n        } catch (e) {\n            deferral.reject(`Error formatting the message. ${e as string}`);\n        }\n\n        return deferral.promise;\n    }\n\n    private makeHeaders(message: ConnectionMessage): string {\n        let headersString: string = \"\";\n\n        if (message.headers) {\n            for (const header in message.headers) {\n                if (header) {\n                    headersString += `${header}: ${message.headers[header]}${CRLF}`;\n                }\n            }\n        }\n\n        return headersString;\n    }\n\n    private parseHeaders(headersString: string): IStringDictionary<string> {\n        const headers: IStringDictionary<string> = {};\n\n        if (headersString) {\n            const headerMatches = headersString.match(/[^\\r\\n]+/g);\n            if (headers) {\n                for (const header of headerMatches) {\n                    if (header) {\n                        const separatorIndex = header.indexOf(\":\");\n                        const headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;\n                        const headerValue =\n                            separatorIndex > 0 && header.length > (separatorIndex + 1) ?\n                                header.substr(separatorIndex + 1).trim() :\n                                \"\";\n\n                        headers[headerName] = headerValue;\n                    }\n                }\n            }\n        }\n\n        return headers;\n    }\n\n    private stringToArrayBuffer(str: string): ArrayBuffer {\n        const buffer = new ArrayBuffer(str.length);\n        const view = new DataView(buffer);\n        for (let i = 0; i < str.length; i++) {\n            view.setUint8(i, str.charCodeAt(i));\n        }\n        return buffer;\n    }\n}\n"]}