{"version":3,"sources":["src/common.speech/ConversationTranscriptionServiceRecognizer.ts"],"names":[],"mappings":"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","file":"ConversationTranscriptionServiceRecognizer.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport { IAudioSource } from \"../common/Exports\";\nimport {\n    CancellationErrorCode,\n    CancellationReason,\n    OutputFormat,\n    PropertyCollection,\n    PropertyId,\n    ResultReason,\n    ConversationTranscriptionCanceledEventArgs,\n    ConversationTranscriptionEventArgs,\n    ConversationTranscriptionResult,\n    ConversationTranscriber,\n} from \"../sdk/Exports\";\nimport {\n    CancellationErrorCodePropertyName,\n    DetailedSpeechPhrase,\n    EnumTranslation,\n    OutputFormatPropertyName,\n    RecognitionStatus,\n    ServiceRecognizerBase,\n    SimpleSpeechPhrase,\n    SpeechHypothesis,\n} from \"./Exports\";\nimport { IAuthentication } from \"./IAuthentication\";\nimport { IConnectionFactory } from \"./IConnectionFactory\";\nimport { RecognizerConfig } from \"./RecognizerConfig\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nimport { PhraseDetection, SpeakerDiarization } from \"./ServiceRecognizerBase\";\n\n// eslint-disable-next-line max-classes-per-file\nexport class ConversationTranscriptionServiceRecognizer extends ServiceRecognizerBase {\n\n    private privConversationTranscriber: ConversationTranscriber;\n\n    public constructor(\n        authentication: IAuthentication,\n        connectionFactory: IConnectionFactory,\n        audioSource: IAudioSource,\n        recognizerConfig: RecognizerConfig,\n        conversationTranscriber: ConversationTranscriber) {\n        super(authentication, connectionFactory, audioSource, recognizerConfig, conversationTranscriber);\n        this.privConversationTranscriber = conversationTranscriber;\n        this.setSpeakerDiarizationJson();\n    }\n\n    protected setSpeakerDiarizationJson(): void {\n        if (this.privEnableSpeakerId) {\n            const phraseDetection = this.privSpeechContext.getSection(\"phraseDetection\") as PhraseDetection;\n            const speakerDiarization: SpeakerDiarization = {};\n            speakerDiarization.mode = \"Anonymous\";\n            speakerDiarization.audioSessionId = this.privDiarizationSessionId;\n            speakerDiarization.audioOffsetMs = 0;\n            phraseDetection.speakerDiarization = speakerDiarization;\n            this.privSpeechContext.setSection(\"phraseDetection\", phraseDetection);\n        }\n    }\n\n    protected async processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\n\n        let result: ConversationTranscriptionResult;\n        const resultProps: PropertyCollection = new PropertyCollection();\n        resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n        let processed: boolean = false;\n\n        switch (connectionMessage.path.toLowerCase()) {\n            case \"speech.hypothesis\":\n            case \"speech.fragment\":\n                const hypothesis: SpeechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\n                const offset: number = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n\n                result = new ConversationTranscriptionResult(\n                    this.privRequestSession.requestId,\n                    ResultReason.RecognizingSpeech,\n                    hypothesis.Text,\n                    hypothesis.Duration,\n                    offset,\n                    hypothesis.Language,\n                    hypothesis.LanguageDetectionConfidence,\n                    undefined, // Speaker Id\n                    undefined,\n                    connectionMessage.textBody,\n                    resultProps);\n\n                this.privRequestSession.onHypothesis(offset);\n\n                const ev = new ConversationTranscriptionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\n\n                if (!!this.privConversationTranscriber.transcribing) {\n                    try {\n                        this.privConversationTranscriber.transcribing(this.privConversationTranscriber, ev);\n                        /* eslint-disable no-empty */\n                    } catch (error) {\n                        // Not going to let errors in the event handler\n                        // trip things up.\n                    }\n                }\n                processed = true;\n                break;\n            case \"speech.phrase\":\n                const simple: SimpleSpeechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n                const resultReason: ResultReason = EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);\n\n                this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);\n\n                if (ResultReason.Canceled === resultReason) {\n                    const cancelReason: CancellationReason = EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);\n                    const cancellationErrorCode: CancellationErrorCode = EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);\n\n                    await this.cancelRecognitionLocal(\n                        cancelReason,\n                        cancellationErrorCode,\n                        EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));\n\n                } else {\n                    if (!(this.privRequestSession.isSpeechEnded && resultReason === ResultReason.NoMatch && simple.RecognitionStatus !== RecognitionStatus.InitialSilenceTimeout)) {\n                        if (this.privRecognizerConfig.parameters.getProperty(OutputFormatPropertyName) === OutputFormat[OutputFormat.Simple]) {\n                            result = new ConversationTranscriptionResult(\n                                this.privRequestSession.requestId,\n                                resultReason,\n                                simple.DisplayText,\n                                simple.Duration,\n                                simple.Offset + this.privRequestSession.currentTurnAudioOffset,\n                                simple.Language,\n                                simple.LanguageDetectionConfidence,\n                                simple.SpeakerId,\n                                undefined,\n                                connectionMessage.textBody,\n                                resultProps);\n                        } else {\n                            const detailed: DetailedSpeechPhrase = DetailedSpeechPhrase.fromJSON(connectionMessage.textBody);\n                            const totalOffset: number = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;\n                            const offsetCorrectedJson: string = detailed.getJsonWithCorrectedOffsets(totalOffset);\n\n                            result = new ConversationTranscriptionResult(\n                                this.privRequestSession.requestId,\n                                resultReason,\n                                detailed.RecognitionStatus === RecognitionStatus.Success ? detailed.NBest[0].Display : undefined,\n                                detailed.Duration,\n                                totalOffset,\n                                detailed.Language,\n                                detailed.LanguageDetectionConfidence,\n                                simple.SpeakerId,\n                                undefined,\n                                offsetCorrectedJson,\n                                resultProps);\n                        }\n\n                        const event: ConversationTranscriptionEventArgs = new ConversationTranscriptionEventArgs(result, result.offset, this.privRequestSession.sessionId);\n\n                        if (!!this.privConversationTranscriber.transcribed) {\n                            try {\n                                this.privConversationTranscriber.transcribed(this.privConversationTranscriber, event);\n                                /* eslint-disable no-empty */\n                            } catch (error) {\n                                // Not going to let errors in the event handler\n                                // trip things up.\n                            }\n                        }\n                    }\n                }\n                processed = true;\n                break;\n            default:\n                break;\n        }\n        return processed;\n    }\n\n    // Cancels recognition.\n    protected cancelRecognition(\n        sessionId: string,\n        requestId: string,\n        cancellationReason: CancellationReason,\n        errorCode: CancellationErrorCode,\n        error: string): void {\n\n        const properties: PropertyCollection = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n\n        if (!!this.privConversationTranscriber.canceled) {\n            const cancelEvent: ConversationTranscriptionCanceledEventArgs = new ConversationTranscriptionCanceledEventArgs(\n                cancellationReason,\n                error,\n                errorCode,\n                undefined,\n                sessionId);\n            try {\n                this.privConversationTranscriber.canceled(this.privConversationTranscriber, cancelEvent);\n                /* eslint-disable no-empty */\n            } catch { }\n        }\n    }\n}\n"]}