{"version":3,"sources":["src/common.speech/Transcription/ConversationManager.ts"],"names":[],"mappings":"AAYA,OAAO,EAAE,kBAAkB,EAAc,MAAM,mBAAmB,CAAC;AAInE,qBAAa,mBAAmB;IAE5B,OAAO,CAAC,iBAAiB,CAAc;IACvC,OAAO,CAAC,UAAU,CAAiB;IACnC,OAAO,CAAC,QAAQ,CAAS;IACzB,OAAO,CAAC,cAAc,CAAS;IAC/B,OAAO,CAAC,YAAY,CAAS;IAC7B,OAAO,CAAC,eAAe,CAAqB;;IAY5C;;;;;;OAMG;IACI,YAAY,CAAC,IAAI,EAAE,kBAAkB,EAAE,gBAAgB,EAAE,MAAM,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC,EAAE,MAAM,KAAK,IAAI,GAAG,IAAI;IAuG/H;;;;;OAKG;IACI,KAAK,CAAC,IAAI,EAAE,kBAAkB,EAAE,YAAY,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;CA+C9E","file":"ConversationManager.d.ts","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport {\n    IRequestOptions,\n    IRestParams,\n    IRestResponse,\n    RestMessageAdapter,\n    RestRequestType\n} from \"../../common.browser/Exports\";\nimport { IErrorMessages, IStringDictionary } from \"../../common/Exports\";\nimport { Contracts } from \"../../sdk/Contracts\";\nimport { PropertyCollection, PropertyId } from \"../../sdk/Exports\";\nimport { ConversationConnectionConfig } from \"./ConversationConnectionConfig\";\nimport { IConversationResponseError, IInternalConversation } from \"./ConversationTranslatorInterfaces\";\n\nexport class ConversationManager {\n\n    private privRequestParams: IRestParams;\n    private privErrors: IErrorMessages;\n    private privHost: string;\n    private privApiVersion: string;\n    private privRestPath: string;\n    private privRestAdapter: RestMessageAdapter;\n\n    public constructor() {\n        //\n        this.privRequestParams = ConversationConnectionConfig.configParams;\n        this.privErrors = ConversationConnectionConfig.restErrors;\n        this.privHost = ConversationConnectionConfig.host;\n        this.privApiVersion = ConversationConnectionConfig.apiVersion;\n        this.privRestPath = ConversationConnectionConfig.restPath;\n        this.privRestAdapter = new RestMessageAdapter({});\n    }\n\n    /**\n     * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.\n     * @param args\n     * @param conversationCode\n     * @param callback\n     * @param errorCallback\n     */\n    public createOrJoin(args: PropertyCollection, conversationCode: string, cb?: (c: any) => void, err?: (e: string) => void): void {\n\n        try {\n\n            Contracts.throwIfNullOrUndefined(args, \"args\");\n\n            const languageCode: string = args.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, ConversationConnectionConfig.defaultLanguageCode);\n            const nickname: string = args.getProperty(PropertyId.ConversationTranslator_Name, \"conversation_host\");\n            const endpointHost: string = args.getProperty(PropertyId.ConversationTranslator_Host, this.privHost);\n            const correlationId: string = args.getProperty(PropertyId.ConversationTranslator_CorrelationId);\n            const subscriptionKey: string = args.getProperty(PropertyId.SpeechServiceConnection_Key);\n            const subscriptionRegion: string = args.getProperty(PropertyId.SpeechServiceConnection_Region);\n            const authToken: string = args.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n\n            Contracts.throwIfNullOrWhitespace(languageCode, \"languageCode\");\n            Contracts.throwIfNullOrWhitespace(nickname, \"nickname\");\n            Contracts.throwIfNullOrWhitespace(endpointHost, \"endpointHost\");\n\n            const queryParams: IStringDictionary<string> = {};\n            queryParams[this.privRequestParams.apiVersion] = this.privApiVersion;\n            queryParams[this.privRequestParams.languageCode] = languageCode;\n            queryParams[this.privRequestParams.nickname] = nickname;\n\n            const headers: IStringDictionary<string> = {};\n            if (correlationId) {\n                headers[this.privRequestParams.correlationId] = correlationId;\n            }\n            headers[this.privRequestParams.clientAppId] = ConversationConnectionConfig.clientAppId;\n\n            if (conversationCode !== undefined) {\n                queryParams[this.privRequestParams.roomId] = conversationCode;\n            } else {\n                Contracts.throwIfNullOrUndefined(subscriptionRegion, this.privErrors.authInvalidSubscriptionRegion);\n                headers[this.privRequestParams.subscriptionRegion] = subscriptionRegion;\n                if (subscriptionKey) {\n                    headers[this.privRequestParams.subscriptionKey] = subscriptionKey;\n                } else if (authToken) {\n                    headers[this.privRequestParams.authorization] = `Bearer ${authToken}`;\n                } else {\n                    Contracts.throwIfNullOrUndefined(subscriptionKey, this.privErrors.authInvalidSubscriptionKey);\n                }\n            }\n\n            const config: IRequestOptions = {};\n            config.headers = headers;\n            this.privRestAdapter.options = config;\n\n            const endpoint: string = `https://${endpointHost}${this.privRestPath}`;\n\n            // TODO: support a proxy and certificate validation\n            this.privRestAdapter.request(RestRequestType.Post, endpoint, queryParams, null).then((response: IRestResponse): void => {\n\n                const requestId: string = RestMessageAdapter.extractHeaderValue(this.privRequestParams.requestId, response.headers);\n\n                if (!response.ok) {\n                    if (!!err) {\n                        // get the error\n                        let errorMessage: string = this.privErrors.invalidCreateJoinConversationResponse.replace(\"{status}\", response.status.toString());\n                        let errMessageRaw: IConversationResponseError;\n                        try {\n                            errMessageRaw = JSON.parse(response.data) as IConversationResponseError;\n                            errorMessage += ` [${errMessageRaw.error.code}: ${errMessageRaw.error.message}]`;\n                        } catch (e) {\n                            errorMessage += ` [${response.data}]`;\n                        }\n                        if (requestId) {\n                            errorMessage += ` ${requestId}`;\n                        }\n\n                        err(errorMessage);\n                    }\n                    return;\n                }\n                const conversation: IInternalConversation = JSON.parse(response.data) as IInternalConversation;\n                if (conversation) {\n                    conversation.requestId = requestId;\n                }\n                if (!!cb) {\n                    try {\n                        cb(conversation);\n                    } catch (e) {\n                        if (!!err) {\n                            err(e as string);\n                        }\n                    }\n                    cb = undefined;\n                }\n            // eslint-disable-next-line @typescript-eslint/no-empty-function\n            }).catch( (): void => { });\n\n        } catch (error) {\n            if (!!err) {\n                if (error instanceof Error) {\n                    const typedError: Error = error;\n                    err(typedError.name + \": \" + typedError.message);\n\n                } else {\n                    err(error as string);\n                }\n            }\n        }\n    }\n\n    /**\n     * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.\n     * @param args\n     * @param sessionToken\n     * @param callback\n     */\n    public leave(args: PropertyCollection, sessionToken: string): Promise<void> {\n        return new Promise<void>((resolve: () => void, reject: (reason: string) => void): void => {\n            try {\n\n                Contracts.throwIfNullOrUndefined(args, this.privErrors.invalidArgs.replace(\"{arg}\", \"config\"));\n                Contracts.throwIfNullOrWhitespace(sessionToken, this.privErrors.invalidArgs.replace(\"{arg}\", \"token\"));\n\n                const endpointHost: string = args.getProperty(PropertyId.ConversationTranslator_Host, this.privHost);\n                const correlationId: string = args.getProperty(PropertyId.ConversationTranslator_CorrelationId);\n\n                const queryParams: IStringDictionary<string> = {};\n                queryParams[this.privRequestParams.apiVersion] = this.privApiVersion;\n                queryParams[this.privRequestParams.sessionToken] = sessionToken;\n\n                const headers: IStringDictionary<string> = {};\n                if (correlationId) {\n                    headers[this.privRequestParams.correlationId] = correlationId;\n                }\n\n                const config: IRequestOptions = {};\n                config.headers = headers;\n                this.privRestAdapter.options = config;\n\n                const endpoint: string = `https://${endpointHost}${this.privRestPath}`;\n\n                // TODO: support a proxy and certificate validation\n                this.privRestAdapter.request(RestRequestType.Delete, endpoint, queryParams, null).then((response: IRestResponse): void => {\n\n                    if (!response.ok) {\n                        // ignore errors on delete\n                    }\n\n                    resolve();\n                // eslint-disable-next-line @typescript-eslint/no-empty-function\n                }).catch( (): void => {});\n\n            } catch (error) {\n                if (error instanceof Error) {\n                    const typedError: Error = error;\n                    reject(typedError.name + \": \" + typedError.message);\n\n                } else {\n                    reject(error as string);\n                }\n            }\n        });\n    }\n}\n"]}