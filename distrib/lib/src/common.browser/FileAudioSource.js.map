{"version":3,"sources":["src/common.browser/FileAudioSource.ts"],"names":[],"mappings":"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","file":"FileAudioSource.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport {\n    connectivity,\n    ISpeechConfigAudioDevice,\n    type,\n} from \"../common.speech/Exports\";\nimport {\n    AudioSourceErrorEvent,\n    AudioSourceEvent,\n    AudioSourceInitializingEvent,\n    AudioSourceOffEvent,\n    AudioSourceReadyEvent,\n    AudioStreamNodeAttachedEvent,\n    AudioStreamNodeAttachingEvent,\n    AudioStreamNodeDetachedEvent,\n    AudioStreamNodeErrorEvent,\n    ChunkedArrayBufferStream,\n    createNoDashGuid,\n    Deferred,\n    Events,\n    EventSource,\n    IAudioSource,\n    IAudioStreamNode,\n    IStreamChunk,\n    IStringDictionary,\n    Stream,\n} from \"../common/Exports\";\nimport { AudioStreamFormat, AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\n\nexport class FileAudioSource implements IAudioSource {\n\n    private privAudioFormatPromise: Promise<AudioStreamFormatImpl>;\n\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\n\n    private privId: string;\n\n    private privEvents: EventSource<AudioSourceEvent>;\n\n    private privSource: Blob | Buffer;\n\n    private privFilename: string;\n\n    private privHeaderEnd: number = 44;\n\n    public constructor(file: File | Buffer, filename?: string, audioSourceId?: string) {\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\n        this.privEvents = new EventSource<AudioSourceEvent>();\n        this.privSource = file;\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && this.privSource instanceof Blob) {\n            this.privFilename = (file as File).name;\n        } else {\n            this.privFilename = filename || \"unknown.wav\";\n        }\n\n        // Read the header.\n        this.privAudioFormatPromise = this.readHeader();\n    }\n\n    public get format(): Promise<AudioStreamFormatImpl> {\n        return this.privAudioFormatPromise;\n    }\n\n    public turnOn(): Promise<void> {\n        if (this.privFilename.lastIndexOf(\".wav\") !== this.privFilename.length - 4) {\n            const errorMsg = this.privFilename + \" is not supported. Only WAVE files are allowed at the moment.\";\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\n            return Promise.reject(errorMsg);\n        }\n\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n        this.onEvent(new AudioSourceReadyEvent(this.privId));\n        return;\n    }\n\n    public id(): string {\n        return this.privId;\n    }\n\n    public async attach(audioNodeId: string): Promise<IAudioStreamNode> {\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n\n        const stream: Stream<ArrayBuffer> = await this.upload(audioNodeId);\n\n        this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n        return Promise.resolve({\n            detach: async (): Promise<void> => {\n                stream.readEnded();\n                delete this.privStreams[audioNodeId];\n                this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n                await this.turnOff();\n            },\n            id: (): string => audioNodeId,\n            read: (): Promise<IStreamChunk<ArrayBuffer>> => stream.read(),\n        });\n    }\n\n    public detach(audioNodeId: string): void {\n        if (audioNodeId && this.privStreams[audioNodeId]) {\n            this.privStreams[audioNodeId].close();\n            delete this.privStreams[audioNodeId];\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n        }\n    }\n\n    public turnOff(): Promise<void> {\n        for (const streamId in this.privStreams) {\n            if (streamId) {\n                const stream = this.privStreams[streamId];\n                if (stream && !stream.isClosed) {\n                    stream.close();\n                }\n            }\n        }\n\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\n        return Promise.resolve();\n    }\n\n    public get events(): EventSource<AudioSourceEvent> {\n        return this.privEvents;\n    }\n\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\n        return this.privAudioFormatPromise.then<ISpeechConfigAudioDevice>((result: AudioStreamFormatImpl): Promise<{\n            bitspersample: number;\n            channelcount: number;\n            connectivity: connectivity.Unknown;\n            manufacturer: string;\n            model: string;\n            samplerate: number;\n            type: type.File;\n        }> => ( Promise.resolve({\n                bitspersample: result.bitsPerSample,\n                channelcount: result.channels,\n                connectivity: connectivity.Unknown,\n                manufacturer: \"Speech SDK\",\n                model: \"File\",\n                samplerate: result.samplesPerSec,\n                type: type.File,\n            })\n        ));\n    }\n\n    private readHeader(): Promise<AudioStreamFormatImpl> {\n        // Read the wave header.\n        const maxHeaderSize: number = 4296;\n        const header: Blob | Buffer = this.privSource.slice(0, maxHeaderSize);\n\n        const headerResult: Deferred<AudioStreamFormatImpl> = new Deferred<AudioStreamFormatImpl>();\n\n        const processHeader = (header: ArrayBuffer): void => {\n            const view: DataView = new DataView(header);\n\n            const getWord = (index: number): string => String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));\n\n            // RIFF 4 bytes.\n            if (\"RIFF\" !== getWord(0)) {\n                headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\n                return;\n            }\n\n            // length, 4 bytes\n            // RIFF Type & fmt 8 bytes\n            if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\n                headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\n                return;\n            }\n\n            const formatSize: number = view.getInt32(16, true);\n            const channelCount: number = view.getUint16(22, true);\n            const sampleRate: number = view.getUint32(24, true);\n            const bitsPerSample: number = view.getUint16(34, true);\n            // Confirm if header is 44 bytes long.\n            let pos: number = 36 + Math.max(formatSize - 16, 0);\n            for (; getWord(pos) !== \"data\"; pos += 2) {\n                if (pos > maxHeaderSize - 8) {\n                    headerResult.reject(\"Invalid WAV header in file, data block was not found\");\n                    return;\n                }\n            }\n            this.privHeaderEnd = pos + 8;\n            headerResult.resolve(AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount) as AudioStreamFormatImpl);\n        };\n\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && header instanceof Blob) {\n            const reader: FileReader = new FileReader();\n\n            reader.onload = (event: Event): void => {\n                const header: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\n                processHeader(header);\n            };\n\n            reader.readAsArrayBuffer(header);\n        } else {\n            const h: Buffer = header as Buffer;\n            processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));\n        }\n        return headerResult.promise;\n    }\n\n    private async upload(audioNodeId: string): Promise<Stream<ArrayBuffer>> {\n        const onerror = (error: string): void => {\n            const errorMsg = `Error occurred while processing '${this.privFilename}'. ${error}`;\n            this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\n            throw new Error(errorMsg);\n        };\n\n        try {\n            await this.turnOn();\n\n            const format: AudioStreamFormatImpl = await this.privAudioFormatPromise;\n            const stream = new ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\n\n            this.privStreams[audioNodeId] = stream;\n            const chunk: Blob | Buffer = this.privSource.slice(this.privHeaderEnd);\n\n            const processFile = (buff: ArrayBuffer): void => {\n                if (stream.isClosed) {\n                    return; // output stream was closed (somebody called TurnOff). We're done here.\n                }\n\n                stream.writeStreamChunk({\n                    buffer: buff,\n                    isEnd: false,\n                    timeReceived: Date.now(),\n                });\n                stream.close();\n            };\n\n            if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && chunk instanceof Blob) {\n                const reader: FileReader = new FileReader();\n                reader.onerror = (ev: ProgressEvent<FileReader>): void  =>  onerror(ev.toString());\n\n                reader.onload = (event: Event): void => {\n                    const fileBuffer: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\n                    processFile(fileBuffer);\n                };\n\n                reader.readAsArrayBuffer(chunk);\n            } else {\n                const c: Buffer = chunk as Buffer;\n                processFile(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));\n            }\n\n            return stream;\n        } catch (e) {\n            onerror(e as string);\n        }\n    }\n\n    private onEvent(event: AudioSourceEvent): void {\n        this.privEvents.onEvent(event);\n        Events.instance.onEvent(event);\n    }\n}\n"]}