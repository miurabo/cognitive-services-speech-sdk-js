{"version":3,"sources":["src/common/Stream.ts"],"names":[],"mappings":";AAAA,4DAA4D;AAC5D,kCAAkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAElC,iCAAgD;AAChD,+BAA0C;AAC1C,iCAAgC;AAQhC;IAMI,gBAAmB,QAAiB;QAJ5B,qBAAgB,GAAY,KAAK,CAAC;QAClC,oBAAe,GAAY,KAAK,CAAC;QAIrC,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,uBAAgB,EAAE,CAAC;QACvD,IAAI,CAAC,eAAe,GAAG,IAAI,aAAK,EAAyB,CAAC;IAC9D,CAAC;IAED,sBAAW,4BAAQ;aAAnB;YACI,OAAO,IAAI,CAAC,gBAAgB,CAAC;QACjC,CAAC;;;OAAA;IAED,sBAAW,+BAAW;aAAtB;YACI,OAAO,IAAI,CAAC,eAAe,CAAC;QAChC,CAAC;;;OAAA;IAED,sBAAW,sBAAE;aAAb;YACI,OAAO,IAAI,CAAC,MAAM,CAAC;QACvB,CAAC;;;OAAA;IAEM,sBAAK,GAAZ;QACI,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE;YACxB,IAAI,CAAC,gBAAgB,CAAC;gBAClB,MAAM,EAAE,IAAI;gBACZ,KAAK,EAAE,IAAI;gBACX,YAAY,EAAE,IAAI,CAAC,GAAG,EAAE;aAC3B,CAAC,CAAC;YACH,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;SAChC;IACL,CAAC;IAEM,iCAAgB,GAAvB,UAAwB,WAAkC;QACtD,IAAI,CAAC,aAAa,EAAE,CAAC;QACrB,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,UAAU,EAAE,EAAE;YACpC,IAAI;gBACA,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;aAC7C;YAAC,OAAO,CAAC,EAAE;gBACR,aAAa;aAChB;SACJ;IACL,CAAC;IAEM,qBAAI,GAAX;QAAA,iBAcC;QAbG,IAAI,IAAI,CAAC,eAAe,EAAE;YACtB,MAAM,IAAI,6BAAqB,CAAC,kCAAkC,CAAC,CAAC;SACvE;QAED,OAAO,IAAI,CAAC,eAAe;aACtB,OAAO,EAAE;aACT,IAAI,CAAC,UAAO,WAAkC;;;;6BACvC,CAAA,WAAW,KAAK,SAAS,IAAI,WAAW,CAAC,KAAK,CAAA,EAA9C,wBAA8C;wBAC9C,qBAAM,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,uBAAuB,CAAC,EAAA;;wBAA3D,SAA2D,CAAC;;4BAGhE,sBAAO,WAAW,EAAC;;;aACtB,CAAC,CAAC;IACX,CAAC;IACM,0BAAS,GAAhB;QACI,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE;YACvB,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;YAC5B,IAAI,CAAC,eAAe,GAAG,IAAI,aAAK,EAAyB,CAAC;SAC7D;IACL,CAAC;IAEO,8BAAa,GAArB;QACI,IAAI,IAAI,CAAC,gBAAgB,EAAE;YACvB,MAAM,IAAI,6BAAqB,CAAC,eAAe,CAAC,CAAC;SACpD;IACL,CAAC;IACL,aAAC;AAAD,CAxEA,AAwEC,IAAA;AAxEY,wBAAM","file":"Stream.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport { InvalidOperationError } from \"./Error\";\nimport { createNoDashGuid } from \"./Guid\";\nimport { Queue } from \"./Queue\";\n\nexport interface IStreamChunk<TBuffer> {\n    isEnd: boolean;\n    buffer: TBuffer;\n    timeReceived: number;\n}\n\nexport class Stream<TBuffer> {\n    private privId: string;\n    private privIsWriteEnded: boolean = false;\n    private privIsReadEnded: boolean = false;\n    private privReaderQueue: Queue<IStreamChunk<TBuffer>>;\n\n    public constructor(streamId?: string) {\n        this.privId = streamId ? streamId : createNoDashGuid();\n        this.privReaderQueue = new Queue<IStreamChunk<TBuffer>>();\n    }\n\n    public get isClosed(): boolean {\n        return this.privIsWriteEnded;\n    }\n\n    public get isReadEnded(): boolean {\n        return this.privIsReadEnded;\n    }\n\n    public get id(): string {\n        return this.privId;\n    }\n\n    public close(): void {\n        if (!this.privIsWriteEnded) {\n            this.writeStreamChunk({\n                buffer: null,\n                isEnd: true,\n                timeReceived: Date.now(),\n            });\n            this.privIsWriteEnded = true;\n        }\n    }\n\n    public writeStreamChunk(streamChunk: IStreamChunk<TBuffer>): void {\n        this.throwIfClosed();\n        if (!this.privReaderQueue.isDisposed()) {\n            try {\n                this.privReaderQueue.enqueue(streamChunk);\n            } catch (e) {\n                // Do nothing\n            }\n        }\n    }\n\n    public read(): Promise<IStreamChunk<TBuffer>> {\n        if (this.privIsReadEnded) {\n            throw new InvalidOperationError(\"Stream read has already finished\");\n        }\n\n        return this.privReaderQueue\n            .dequeue()\n            .then(async (streamChunk: IStreamChunk<TBuffer>): Promise<IStreamChunk<TBuffer>> => {\n                if (streamChunk === undefined || streamChunk.isEnd) {\n                    await this.privReaderQueue.dispose(\"End of stream reached\");\n                }\n\n                return streamChunk;\n            });\n    }\n    public readEnded(): void {\n        if (!this.privIsReadEnded) {\n            this.privIsReadEnded = true;\n            this.privReaderQueue = new Queue<IStreamChunk<TBuffer>>();\n        }\n    }\n\n    private throwIfClosed(): void {\n        if (this.privIsWriteEnded) {\n            throw new InvalidOperationError(\"Stream closed\");\n        }\n    }\n}\n"]}