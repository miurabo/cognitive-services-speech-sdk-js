{"version":3,"sources":["src/common/StringUtils.ts"],"names":[],"mappings":";AAAA,4DAA4D;AAC5D,kCAAkC;;;AAIlC;;GAEG;AACH;IAAA;IAiEA,CAAC;IA/DG;;;;;;OAMG;IACW,wBAAY,GAA1B,UAA2B,MAAc,EAAE,YAAuC;QAC9E,IAAI,CAAC,MAAM,EAAE;YACT,OAAO,EAAE,CAAC;SACb;QAED,IAAI,CAAC,YAAY,EAAE;YACf,OAAO,MAAM,CAAC;SACjB;QAED,IAAI,SAAS,GAAW,EAAE,CAAC;QAC3B,IAAI,GAAG,GAAW,EAAE,CAAC;QAErB,IAAM,iBAAiB,GAAG,UAAC,GAAW;YAClC,SAAS,IAAI,GAAG,CAAC;QACrB,CAAC,CAAC;QACF,IAAM,WAAW,GAAG,UAAC,GAAW;YAC5B,GAAG,IAAI,GAAG,CAAC;QACf,CAAC,CAAC;QACF,IAAI,UAAU,GAA0B,iBAAiB,CAAC;QAE1D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACpC,IAAM,CAAC,GAAW,MAAM,CAAC,CAAC,CAAC,CAAC;YAC5B,IAAM,IAAI,GAAW,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;YAEhE,QAAQ,CAAC,EAAE;gBACP,KAAK,GAAG;oBACJ,IAAI,IAAI,KAAK,GAAG,EAAE;wBACd,UAAU,CAAC,GAAG,CAAC,CAAC;wBAChB,CAAC,EAAE,CAAC;qBACP;yBAAM;wBACH,UAAU,GAAG,WAAW,CAAC;qBAC5B;oBACD,MAAM;gBAEV,KAAK,GAAG;oBACJ,IAAI,IAAI,KAAK,GAAG,EAAE;wBACd,UAAU,CAAC,GAAG,CAAC,CAAC;wBAChB,CAAC,EAAE,CAAC;qBACP;yBAAM;wBACH,IAAI,YAAY,CAAC,cAAc,CAAC,GAAG,CAAC,EAAE;4BAClC,SAAS,IAAI,YAAY,CAAC,GAAG,CAAC,CAAC;yBAClC;wBAED,UAAU,GAAG,iBAAiB,CAAC;wBAC/B,GAAG,GAAG,EAAE,CAAC;qBACZ;oBACD,MAAM;gBAEV;oBACI,UAAU,CAAC,CAAC,CAAC,CAAC;oBACd,MAAM;aACb;SACJ;QAED,OAAO,SAAS,CAAC;IACrB,CAAC;IACL,kBAAC;AAAD,CAjEA,AAiEC,IAAA;AAjEY,kCAAW","file":"StringUtils.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport { IStringDictionary } from \"./IDictionary\";\n\n/**\n * String helper functions\n */\nexport class StringUtils {\n\n    /**\n     * Formats a string by replacing the named {keys} in the string with the values contained in the replacement dictionary.\n     * @param format The format string that contains the parts to replace surrounded by {}. For example: \"wss://{region}.cts.speech.microsoft.com\".\n     * If your string needs to contain a { or } you can use the {{ and }} escape sequences respectively.\n     * @param replacements The dictionary of replacements. If a replacement is not found, it is replaced with an empty string\n     * @returns The formatted string. If you pass in a null or undefined format string, an empty string will be returned\n     */\n    public static formatString(format: string, replacements: IStringDictionary<string>): string {\n        if (!format) {\n            return \"\";\n        }\n\n        if (!replacements) {\n            return format;\n        }\n\n        let formatted: string = \"\";\n        let key: string = \"\";\n\n        const appendToFormatted = (str: string): void => {\n            formatted += str;\n        };\n        const appendToKey = (str: string): void => {\n            key += str;\n        };\n        let appendFunc: (str: string) => void = appendToFormatted;\n\n        for (let i = 0; i < format.length; i++) {\n            const c: string = format[i];\n            const next: string = i + 1 < format.length ? format[i + 1] : \"\";\n\n            switch (c) {\n                case \"{\":\n                    if (next === \"{\") {\n                        appendFunc(\"{\");\n                        i++;\n                    } else {\n                        appendFunc = appendToKey;\n                    }\n                    break;\n\n                case \"}\":\n                    if (next === \"}\") {\n                        appendFunc(\"}\");\n                        i++;\n                    } else {\n                        if (replacements.hasOwnProperty(key)) {\n                            formatted += replacements[key];\n                        }\n\n                        appendFunc = appendToFormatted;\n                        key = \"\";\n                    }\n                    break;\n\n                default:\n                    appendFunc(c);\n                    break;\n            }\n        }\n\n        return formatted;\n    }\n}\n"]}