{"version":3,"sources":["src/common/ChunkedArrayBufferStream.ts"],"names":[],"mappings":";AAAA,4DAA4D;AAC5D,kCAAkC;;;;;;;;;;;;;;;;AAElC,qCAAiD;AAEjD;IAA8C,4CAAmB;IAM7D,kCAAmB,eAAuB,EAAE,QAAiB;QAA7D,YACI,kBAAM,QAAQ,CAAC,SAGlB;QAFG,KAAI,CAAC,mBAAmB,GAAG,eAAe,CAAC;QAC3C,KAAI,CAAC,wBAAwB,GAAG,CAAC,CAAC;;IACtC,CAAC;IAEM,mDAAgB,GAAvB,UAAwB,KAAgC;QACpD,kEAAkE;QAClE,IAAI,KAAK,CAAC,KAAK;YACX,CAAC,CAAC,KAAK,IAAI,CAAC,wBAAwB,IAAI,KAAK,CAAC,MAAM,CAAC,UAAU,KAAK,IAAI,CAAC,mBAAmB,CAAC,EAAE;YAC/F,iBAAM,gBAAgB,YAAC,KAAK,CAAC,CAAC;YAC9B,OAAO;SACV;QAED,IAAI,qBAAqB,GAAW,CAAC,CAAC;QAEtC,OAAO,qBAAqB,GAAG,KAAK,CAAC,MAAM,CAAC,UAAU,EAAE;YACpD,wBAAwB;YACxB,IAAI,SAAS,KAAK,IAAI,CAAC,qBAAqB,EAAE;gBAC1C,IAAI,CAAC,qBAAqB,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;gBACvE,IAAI,CAAC,uBAAuB,GAAG,KAAK,CAAC,YAAY,CAAC;aACrD;YAED,4DAA4D;YAC5D,IAAM,WAAW,GAAW,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,UAAU,GAAG,qBAAqB,EAAE,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC,wBAAwB,CAAC,CAAC;YAChJ,IAAM,UAAU,GAAe,IAAI,UAAU,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;YAC1E,IAAM,UAAU,GAAe,IAAI,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,qBAAqB,EAAE,WAAW,GAAG,qBAAqB,CAAC,CAAC,CAAC;YAE9H,UAAU,CAAC,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,wBAAwB,CAAC,CAAC;YAC1D,IAAI,CAAC,wBAAwB,IAAI,WAAW,CAAC;YAC7C,qBAAqB,IAAI,WAAW,CAAC;YAErC,yBAAyB;YACzB,IAAI,IAAI,CAAC,wBAAwB,KAAK,IAAI,CAAC,mBAAmB,EAAE;gBAC5D,iBAAM,gBAAgB,YAAC;oBACnB,MAAM,EAAE,IAAI,CAAC,qBAAqB;oBAClC,KAAK,EAAE,KAAK;oBACZ,YAAY,EAAE,IAAI,CAAC,uBAAuB;iBAC7C,CAAC,CAAC;gBACH,IAAI,CAAC,wBAAwB,GAAG,CAAC,CAAC;gBAClC,IAAI,CAAC,qBAAqB,GAAG,SAAS,CAAC;aAC1C;SACJ;IACL,CAAC;IAEM,wCAAK,GAAZ;QACI,uDAAuD;QACvD,IAAI,CAAC,KAAK,IAAI,CAAC,wBAAwB,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YACvD,iBAAM,gBAAgB,YAAC;gBACnB,MAAM,EAAE,IAAI,CAAC,qBAAqB,CAAC,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,wBAAwB,CAAC;gBAC1E,KAAK,EAAE,KAAK;gBACZ,YAAY,EAAE,IAAI,CAAC,uBAAuB;aAC7C,CAAC,CAAC;SACN;QAED,iBAAM,KAAK,WAAE,CAAC;IAClB,CAAC;IACL,+BAAC;AAAD,CA/DA,AA+DC,CA/D6C,gBAAM,GA+DnD;AA/DY,4DAAwB","file":"ChunkedArrayBufferStream.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport { IStreamChunk, Stream } from \"./Exports\";\n\nexport class ChunkedArrayBufferStream extends Stream<ArrayBuffer> {\n    private privTargetChunkSize: number;\n    private privNextBufferToWrite: ArrayBuffer;\n    private privNextBufferStartTime: number;\n    private privNextBufferReadyBytes: number;\n\n    public constructor(targetChunkSize: number, streamId?: string) {\n        super(streamId);\n        this.privTargetChunkSize = targetChunkSize;\n        this.privNextBufferReadyBytes = 0;\n    }\n\n    public writeStreamChunk(chunk: IStreamChunk<ArrayBuffer>): void {\n        // No pending write, and the buffer is the right size so write it.\n        if (chunk.isEnd ||\n            (0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize)) {\n            super.writeStreamChunk(chunk);\n            return;\n        }\n\n        let bytesCopiedFromBuffer: number = 0;\n\n        while (bytesCopiedFromBuffer < chunk.buffer.byteLength) {\n            // Fill the next buffer.\n            if (undefined === this.privNextBufferToWrite) {\n                this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize);\n                this.privNextBufferStartTime = chunk.timeReceived;\n            }\n\n            // Find out how many bytes we can copy into the read buffer.\n            const bytesToCopy: number = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes);\n            const targetView: Uint8Array = new Uint8Array(this.privNextBufferToWrite);\n            const sourceView: Uint8Array = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));\n\n            targetView.set(sourceView, this.privNextBufferReadyBytes);\n            this.privNextBufferReadyBytes += bytesToCopy;\n            bytesCopiedFromBuffer += bytesToCopy;\n\n            // Are we ready to write?\n            if (this.privNextBufferReadyBytes === this.privTargetChunkSize) {\n                super.writeStreamChunk({\n                    buffer: this.privNextBufferToWrite,\n                    isEnd: false,\n                    timeReceived: this.privNextBufferStartTime,\n                });\n                this.privNextBufferReadyBytes = 0;\n                this.privNextBufferToWrite = undefined;\n            }\n        }\n    }\n\n    public close(): void {\n        // Send whatever is pending, then close the base class.\n        if (0 !== this.privNextBufferReadyBytes && !this.isClosed) {\n            super.writeStreamChunk({\n                buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),\n                isEnd: false,\n                timeReceived: this.privNextBufferStartTime,\n            });\n        }\n\n        super.close();\n    }\n}\n"]}