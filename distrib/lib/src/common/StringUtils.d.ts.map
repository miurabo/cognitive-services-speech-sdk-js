{"version":3,"sources":["src/common/StringUtils.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,iBAAiB,EAAE,MAAM,eAAe,CAAC;AAElD;;GAEG;AACH,qBAAa,WAAW;IAEpB;;;;;;OAMG;WACW,YAAY,CAAC,MAAM,EAAE,MAAM,EAAE,YAAY,EAAE,iBAAiB,CAAC,MAAM,CAAC,GAAG,MAAM;CAwD9F","file":"StringUtils.d.ts","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport { IStringDictionary } from \"./IDictionary\";\n\n/**\n * String helper functions\n */\nexport class StringUtils {\n\n    /**\n     * Formats a string by replacing the named {keys} in the string with the values contained in the replacement dictionary.\n     * @param format The format string that contains the parts to replace surrounded by {}. For example: \"wss://{region}.cts.speech.microsoft.com\".\n     * If your string needs to contain a { or } you can use the {{ and }} escape sequences respectively.\n     * @param replacements The dictionary of replacements. If a replacement is not found, it is replaced with an empty string\n     * @returns The formatted string. If you pass in a null or undefined format string, an empty string will be returned\n     */\n    public static formatString(format: string, replacements: IStringDictionary<string>): string {\n        if (!format) {\n            return \"\";\n        }\n\n        if (!replacements) {\n            return format;\n        }\n\n        let formatted: string = \"\";\n        let key: string = \"\";\n\n        const appendToFormatted = (str: string): void => {\n            formatted += str;\n        };\n        const appendToKey = (str: string): void => {\n            key += str;\n        };\n        let appendFunc: (str: string) => void = appendToFormatted;\n\n        for (let i = 0; i < format.length; i++) {\n            const c: string = format[i];\n            const next: string = i + 1 < format.length ? format[i + 1] : \"\";\n\n            switch (c) {\n                case \"{\":\n                    if (next === \"{\") {\n                        appendFunc(\"{\");\n                        i++;\n                    } else {\n                        appendFunc = appendToKey;\n                    }\n                    break;\n\n                case \"}\":\n                    if (next === \"}\") {\n                        appendFunc(\"}\");\n                        i++;\n                    } else {\n                        if (replacements.hasOwnProperty(key)) {\n                            formatted += replacements[key];\n                        }\n\n                        appendFunc = appendToFormatted;\n                        key = \"\";\n                    }\n                    break;\n\n                default:\n                    appendFunc(c);\n                    break;\n            }\n        }\n\n        return formatted;\n    }\n}\n"]}