{"version":3,"sources":["src/sdk/Connection.ts"],"names":[],"mappings":"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","file":"Connection.js","sourcesContent":["//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\n\nimport {\n    ServiceRecognizerBase,\n    SynthesisAdapterBase,\n} from \"../common.speech/Exports\";\nimport {\n    ConnectionEvent,\n    ConnectionMessageReceivedEvent,\n    ConnectionMessageSentEvent,\n    IDetachable,\n    marshalPromiseToCallbacks,\n    ServiceEvent,\n} from \"../common/Exports\";\nimport {\n    ConnectionMessageImpl\n} from \"./ConnectionMessage\";\nimport { Contracts } from \"./Contracts\";\nimport {\n    ConnectionEventArgs,\n    ConnectionMessageEventArgs,\n    ConversationTranscriber,\n    Recognizer,\n    ServiceEventArgs,\n    SpeechSynthesizer,\n} from \"./Exports\";\n\n/**\n * Connection is a proxy class for managing connection to the speech service of the specified Recognizer.\n * By default, a Recognizer autonomously manages connection to service when needed.\n * The Connection class provides additional methods for users to explicitly open or close a connection and\n * to subscribe to connection status changes.\n * The use of Connection is optional, and mainly for scenarios where fine tuning of application\n * behavior based on connection status is needed. Users can optionally call Open() to manually set up a connection\n * in advance before starting recognition on the Recognizer associated with this Connection.\n * If the Recognizer needs to connect or disconnect to service, it will\n * setup or shutdown the connection independently. In this case the Connection will be notified by change of connection\n * status via Connected/Disconnected events.\n * Added in version 1.2.1.\n */\nexport class Connection {\n    private privInternalData: ServiceRecognizerBase | SynthesisAdapterBase;\n    private privEventListener: IDetachable;\n    private privServiceEventListener: IDetachable;\n\n    /**\n     * Gets the Connection instance from the specified recognizer.\n     * @param recognizer The recognizer associated with the connection.\n     * @return The Connection instance of the recognizer.\n     */\n    public static fromRecognizer(recognizer: Recognizer | ConversationTranscriber): Connection {\n        const recoBase = recognizer.internalData as ServiceRecognizerBase;\n        const ret: Connection = new Connection();\n\n        ret.privInternalData = recoBase;\n        ret.setupEvents();\n        return ret;\n    }\n\n    /**\n     * Gets the Connection instance from the specified synthesizer.\n     * @param synthesizer The synthesizer associated with the connection.\n     * @return The Connection instance of the synthesizer.\n     */\n    public static fromSynthesizer(synthesizer: SpeechSynthesizer): Connection {\n        const synthBase: SynthesisAdapterBase = synthesizer.internalData as SynthesisAdapterBase;\n\n        const ret: Connection = new Connection();\n\n        ret.privInternalData = synthBase;\n        ret.setupEvents();\n        return ret;\n    }\n\n    /**\n     * Starts to set up connection to the service.\n     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the\n     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect\n     *\n     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to\n     * be notified when the connection is established.\n     */\n    public openConnection(cb?: () => void, err?: (error: string) => void): void {\n        marshalPromiseToCallbacks(this.privInternalData.connect(), cb, err);\n    }\n\n    /**\n     * Closes the connection the service.\n     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.\n     *\n     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.\n     */\n    public closeConnection(cb?: () => void, err?: (error: string) => void): void {\n        if (this.privInternalData instanceof SynthesisAdapterBase) {\n            throw new Error(\"Disconnecting a synthesizer's connection is currently not supported\");\n        } else {\n            marshalPromiseToCallbacks(this.privInternalData.disconnect(), cb, err);\n        }\n    }\n\n    /**\n     * Appends a parameter in a message to service.\n     * Added in version 1.12.1.\n     * @param path The path of the network message.\n     * @param propertyName Name of the property\n     * @param propertyValue Value of the property. This is a json string.\n     */\n    public setMessageProperty(path: string, propertyName: string, propertyValue: string | object): void {\n        Contracts.throwIfNullOrWhitespace(propertyName, \"propertyName\");\n\n        if (this.privInternalData instanceof ServiceRecognizerBase) {\n            if (path.toLowerCase() !== \"speech.context\") {\n                throw new Error(\"Only speech.context message property sets are currently supported for recognizer\");\n            } else {\n                this.privInternalData.speechContext.setSection(propertyName, propertyValue);\n            }\n        } else if (this.privInternalData instanceof SynthesisAdapterBase) {\n            if (path.toLowerCase() !== \"synthesis.context\") {\n                throw new Error(\"Only synthesis.context message property sets are currently supported for synthesizer\");\n            } else {\n                this.privInternalData.synthesisContext.setSection(propertyName, propertyValue);\n            }\n        }\n    }\n\n    /**\n     * Sends a message to the speech service.\n     * Added in version 1.13.0.\n     * @param path The WebSocket path of the message\n     * @param payload The payload of the message. This is a json string or a ArrayBuffer.\n     * @param success A callback to indicate success.\n     * @param error A callback to indicate an error.\n     */\n    public sendMessageAsync(path: string, payload: string | ArrayBuffer, success?: () => void, error?: (error: string) => void): void {\n        marshalPromiseToCallbacks(this.privInternalData.sendNetworkMessage(path, payload), success, error);\n    }\n\n    /**\n     * Any message from service that is not being processed by any other top level recognizers.\n     *\n     * Will be removed in 2.0.\n     */\n    public receivedServiceMessage: (args: ServiceEventArgs) => void;\n\n    /**\n     * Any message received from the Speech Service.\n     */\n    public messageReceived: (args: ConnectionMessageEventArgs) => void;\n\n    /**\n     * Any message sent to the Speech Service.\n     */\n    public messageSent: (args: ConnectionMessageEventArgs) => void;\n\n    /**\n     * The Connected event to indicate that the recognizer is connected to service.\n     */\n    public connected: (args: ConnectionEventArgs) => void;\n\n    /**\n     * The Disconnected event to indicate that the recognizer is disconnected from service.\n     */\n    public disconnected: (args: ConnectionEventArgs) => void;\n\n    /**\n     * Dispose of associated resources.\n     */\n    public close(): void {\n        /* eslint-disable no-empty */\n    }\n\n    private setupEvents(): void {\n        this.privEventListener = this.privInternalData.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\n            if (connectionEvent.name === \"ConnectionEstablishedEvent\") {\n                if (!!this.connected) {\n                    this.connected(new ConnectionEventArgs(connectionEvent.connectionId));\n                }\n            } else if (connectionEvent.name === \"ConnectionClosedEvent\") {\n                if (!!this.disconnected) {\n                    this.disconnected(new ConnectionEventArgs(connectionEvent.connectionId));\n                }\n            } else if (connectionEvent.name === \"ConnectionMessageSentEvent\") {\n                if (!!this.messageSent) {\n                    this.messageSent(new ConnectionMessageEventArgs(new ConnectionMessageImpl((connectionEvent as ConnectionMessageSentEvent).message)));\n                }\n            } else if (connectionEvent.name === \"ConnectionMessageReceivedEvent\") {\n                if (!!this.messageReceived) {\n                    this.messageReceived(new ConnectionMessageEventArgs(new ConnectionMessageImpl((connectionEvent as ConnectionMessageReceivedEvent).message)));\n                }\n            }\n        });\n\n        this.privServiceEventListener = this.privInternalData.serviceEvents.attach((e: ServiceEvent): void => {\n            if (!!this.receivedServiceMessage) {\n                this.receivedServiceMessage(new ServiceEventArgs(e.jsonString, e.name));\n            }\n        });\n    }\n}\n"]}