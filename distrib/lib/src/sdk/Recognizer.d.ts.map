{"version":3,"sources":["src/sdk/Recognizer.ts"],"names":[],"mappings":"AAGA,OAAO,EAIH,eAAe,EACf,kBAAkB,EAElB,eAAe,EACf,gBAAgB,EAChB,qBAAqB,EACrB,mBAAmB,EACtB,MAAM,0BAA0B,CAAC;AAQlC,OAAO,EACH,WAAW,EACX,kBAAkB,EAElB,oBAAoB,EACpB,gBAAgB,EAChB,uBAAuB,EAC1B,MAAM,WAAW,CAAC;AAEnB;;;GAGG;AACH,8BAAsB,UAAU;IAC5B,OAAO,CAAC,YAAY,CAAU;IAC9B,SAAS,CAAC,WAAW,EAAE,WAAW,CAAC;IACnC,SAAS,CAAC,QAAQ,EAAE,qBAAqB,CAAC;IAC1C,SAAS,CAAC,cAAc,EAAE,kBAAkB,CAAC;IAC7C,OAAO,CAAC,qBAAqB,CAAqB;IAElD;;;;OAIG;IACH,SAAS,aAAa,WAAW,EAAE,WAAW,EAAE,UAAU,EAAE,kBAAkB,EAAE,iBAAiB,EAAE,kBAAkB;IAQrH;;;;;OAKG;IACI,cAAc,EAAE,CAAC,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,gBAAgB,KAAK,IAAI,CAAC;IAE7E;;;;;OAKG;IACI,cAAc,EAAE,CAAC,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,gBAAgB,KAAK,IAAI,CAAC;IAE7E;;;;;OAKG;IACI,mBAAmB,EAAE,CAAC,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,oBAAoB,KAAK,IAAI,CAAC;IAEtF;;;;;OAKG;IACI,iBAAiB,EAAE,CAAC,MAAM,EAAE,UAAU,EAAE,KAAK,EAAE,oBAAoB,KAAK,IAAI,CAAC;IAEpF;;;;;OAKG;IACI,KAAK,CAAC,EAAE,CAAC,EAAE,MAAM,IAAI,EAAE,OAAO,CAAC,EAAE,CAAC,KAAK,EAAE,MAAM,KAAK,IAAI,GAAG,IAAI;IAKtE;;;;OAIG;IACH,IAAW,YAAY,IAAI,MAAM,CAEhC;IAED;;;;;;;;;OASG;cACa,OAAO,CAAC,SAAS,EAAE,OAAO,GAAG,OAAO,CAAC,IAAI,CAAC;IAe1D;;;;;;OAMG;IACH,WAAkB,gBAAgB,IAAI,OAAO,CAE5C;IAED;;;;;;;;;OASG;WACW,eAAe,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI;IAUrD,SAAS,CAAC,QAAQ,CAAC,sBAAsB,CAAC,YAAY,EAAE,mBAAmB,GAAG,gBAAgB;IAG9F,SAAS,CAAC,QAAQ,CAAC,uBAAuB,CACtC,cAAc,EAAE,eAAe,EAC/B,iBAAiB,EAAE,kBAAkB,EACrC,WAAW,EAAE,WAAW,EACxB,gBAAgB,EAAE,gBAAgB,GAAG,qBAAqB;IAG9D,SAAS,CAAC,yBAAyB,IAAI,IAAI;cAuB3B,sBAAsB,CAAC,eAAe,EAAE,eAAe,GAAG,OAAO,CAAC,uBAAuB,CAAC;cAa1F,mCAAmC,CAAC,eAAe,EAAE,eAAe,GAAG,OAAO,CAAC,IAAI,CAAC;cAOpF,kCAAkC,IAAI,OAAO,CAAC,IAAI,CAAC;cAKnD,kBAAkB,IAAI,OAAO,CAAC,IAAI,CAAC;IAOnD,SAAS,CAAC,MAAM,CAAC,qBAAqB,CAAC,UAAU,EAAE,kBAAkB,GAAG,eAAe;CAgB1F","file":"Recognizer.d.ts","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport {\n    CognitiveSubscriptionKeyAuthentication,\n    CognitiveTokenAuthentication,\n    Context,\n    IAuthentication,\n    IConnectionFactory,\n    OS,\n    RecognitionMode,\n    RecognizerConfig,\n    ServiceRecognizerBase,\n    SpeechServiceConfig,\n} from \"../common.speech/Exports\";\nimport {\n    Deferred,\n    marshalPromiseToCallbacks\n} from \"../common/Exports\";\nimport {\n    Contracts\n} from \"./Contracts\";\nimport {\n    AudioConfig,\n    PropertyCollection,\n    PropertyId,\n    RecognitionEventArgs,\n    SessionEventArgs,\n    SpeechRecognitionResult,\n} from \"./Exports\";\n\n/**\n * Defines the base class Recognizer which mainly contains common event handlers.\n * @class Recognizer\n */\nexport abstract class Recognizer {\n    private privDisposed: boolean;\n    protected audioConfig: AudioConfig;\n    protected privReco: ServiceRecognizerBase;\n    protected privProperties: PropertyCollection;\n    private privConnectionFactory: IConnectionFactory;\n\n    /**\n     * Creates and initializes an instance of a Recognizer\n     * @constructor\n     * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer\n     */\n    protected constructor(audioConfig: AudioConfig, properties: PropertyCollection, connectionFactory: IConnectionFactory) {\n        this.audioConfig = (audioConfig !== undefined) ? audioConfig : AudioConfig.fromDefaultMicrophoneInput();\n        this.privDisposed = false;\n        this.privProperties = properties.clone();\n        this.privConnectionFactory = connectionFactory;\n        this.implCommonRecognizerSetup();\n    }\n\n    /**\n     * Defines event handler for session started events.\n     * @member Recognizer.prototype.sessionStarted\n     * @function\n     * @public\n     */\n    public sessionStarted: (sender: Recognizer, event: SessionEventArgs) => void;\n\n    /**\n     * Defines event handler for session stopped events.\n     * @member Recognizer.prototype.sessionStopped\n     * @function\n     * @public\n     */\n    public sessionStopped: (sender: Recognizer, event: SessionEventArgs) => void;\n\n    /**\n     * Defines event handler for speech started events.\n     * @member Recognizer.prototype.speechStartDetected\n     * @function\n     * @public\n     */\n    public speechStartDetected: (sender: Recognizer, event: RecognitionEventArgs) => void;\n\n    /**\n     * Defines event handler for speech stopped events.\n     * @member Recognizer.prototype.speechEndDetected\n     * @function\n     * @public\n     */\n    public speechEndDetected: (sender: Recognizer, event: RecognitionEventArgs) => void;\n\n    /**\n     * Dispose of associated resources.\n     * @member Recognizer.prototype.close\n     * @function\n     * @public\n     */\n    public close(cb?: () => void, errorCb?: (error: string) => void): void {\n        Contracts.throwIfDisposed(this.privDisposed);\n        marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);\n    }\n\n    /**\n     * @Internal\n     * Internal data member to support fromRecognizer* pattern methods on other classes.\n     * Do not use externally, object returned will change without warning or notice.\n     */\n    public get internalData(): object {\n        return this.privReco;\n    }\n\n    /**\n     * This method performs cleanup of resources.\n     * The Boolean parameter disposing indicates whether the method is called\n     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).\n     * Derived classes should override this method to dispose resource if needed.\n     * @member Recognizer.prototype.dispose\n     * @function\n     * @public\n     * @param {boolean} disposing - Flag to request disposal.\n     */\n    protected async dispose(disposing: boolean): Promise<void> {\n        if (this.privDisposed) {\n            return;\n        }\n\n        this.privDisposed = true;\n\n        if (disposing) {\n            if (this.privReco) {\n                await this.privReco.audioSource.turnOff();\n                await this.privReco.dispose();\n            }\n        }\n    }\n\n    /**\n     * This method returns the current state of the telemetry setting.\n     * @member Recognizer.prototype.telemetryEnabled\n     * @function\n     * @public\n     * @returns true if the telemetry is enabled, false otherwise.\n     */\n    public static get telemetryEnabled(): boolean {\n        return ServiceRecognizerBase.telemetryDataEnabled;\n    }\n\n    /**\n     * This method globally enables or disables telemetry.\n     * @member Recognizer.prototype.enableTelemetry\n     * @function\n     * @public\n     * @param enabled - Global setting for telemetry collection.\n     * If set to true, telemetry information like microphone errors,\n     * recognition errors are collected and sent to Microsoft.\n     * If set to false, no telemetry is sent to Microsoft.\n     */\n    public static enableTelemetry(enabled: boolean): void {\n        ServiceRecognizerBase.telemetryDataEnabled = enabled;\n    }\n\n    //\n    // ################################################################################################################\n    // IMPLEMENTATION.\n    // Move to independent class\n    // ################################################################################################################\n    //\n    protected abstract createRecognizerConfig(speechConfig: SpeechServiceConfig): RecognizerConfig;\n\n    // Creates the correct service recognizer for the type\n    protected abstract createServiceRecognizer(\n        authentication: IAuthentication,\n        connectionFactory: IConnectionFactory,\n        audioConfig: AudioConfig,\n        recognizerConfig: RecognizerConfig): ServiceRecognizerBase;\n\n    // Does the generic recognizer setup that is common across all recognizer types.\n    protected implCommonRecognizerSetup(): void {\n\n        let osPlatform = (typeof window !== \"undefined\") ? \"Browser\" : \"Node\";\n        let osName = \"unknown\";\n        let osVersion = \"unknown\";\n\n        if (typeof navigator !== \"undefined\") {\n            osPlatform = osPlatform + \"/\" + navigator.platform;\n            osName = navigator.userAgent;\n            osVersion = navigator.appVersion;\n        }\n\n        const recognizerConfig = this.createRecognizerConfig(\n            new SpeechServiceConfig(\n                new Context(new OS(osPlatform, osName, osVersion))));\n\n        this.privReco = this.createServiceRecognizer(\n            Recognizer.getAuthFromProperties(this.privProperties),\n            this.privConnectionFactory,\n            this.audioConfig,\n            recognizerConfig);\n    }\n\n    protected async recognizeOnceAsyncImpl(recognitionMode: RecognitionMode): Promise<SpeechRecognitionResult> {\n        Contracts.throwIfDisposed(this.privDisposed);\n        const ret: Deferred<SpeechRecognitionResult> = new Deferred<SpeechRecognitionResult>();\n\n        await this.implRecognizerStop();\n        await this.privReco.recognize(recognitionMode, ret.resolve, ret.reject);\n        const result: SpeechRecognitionResult = await ret.promise;\n        await this.implRecognizerStop();\n\n        return result;\n\n    }\n\n    protected async startContinuousRecognitionAsyncImpl(recognitionMode: RecognitionMode): Promise<void> {\n        Contracts.throwIfDisposed(this.privDisposed);\n\n        await this.implRecognizerStop();\n        await this.privReco.recognize(recognitionMode, undefined, undefined);\n    }\n\n    protected async stopContinuousRecognitionAsyncImpl(): Promise<void> {\n        Contracts.throwIfDisposed(this.privDisposed);\n        await this.implRecognizerStop();\n    }\n\n    protected async implRecognizerStop(): Promise<void> {\n        if (this.privReco) {\n            await this.privReco.stopRecognizing();\n        }\n        return;\n    }\n\n    protected static getAuthFromProperties(properties: PropertyCollection): IAuthentication {\n        const subscriptionKey = properties.getProperty(PropertyId.SpeechServiceConnection_Key, undefined);\n        const authentication = (subscriptionKey && subscriptionKey !== \"\") ?\n            new CognitiveSubscriptionKeyAuthentication(subscriptionKey) :\n            new CognitiveTokenAuthentication(\n                (): Promise<string> => {\n                    const authorizationToken = properties.getProperty(PropertyId.SpeechServiceAuthorization_Token, undefined);\n                    return Promise.resolve(authorizationToken);\n                },\n                (): Promise<string> => {\n                    const authorizationToken = properties.getProperty(PropertyId.SpeechServiceAuthorization_Token, undefined);\n                    return Promise.resolve(authorizationToken);\n                });\n\n        return authentication;\n    }\n}\n"]}