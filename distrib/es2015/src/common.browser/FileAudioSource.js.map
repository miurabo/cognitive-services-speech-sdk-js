{"version":3,"sources":["src/common.browser/FileAudioSource.ts"],"names":[],"mappings":"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","file":"FileAudioSource.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport {\n    connectivity,\n    ISpeechConfigAudioDevice,\n    type,\n} from \"../common.speech/Exports\";\nimport {\n    AudioSourceErrorEvent,\n    AudioSourceEvent,\n    AudioSourceInitializingEvent,\n    AudioSourceOffEvent,\n    AudioSourceReadyEvent,\n    AudioStreamNodeAttachedEvent,\n    AudioStreamNodeAttachingEvent,\n    AudioStreamNodeDetachedEvent,\n    AudioStreamNodeErrorEvent,\n    ChunkedArrayBufferStream,\n    createNoDashGuid,\n    Deferred,\n    Events,\n    EventSource,\n    IAudioSource,\n    IAudioStreamNode,\n    IStreamChunk,\n    IStringDictionary,\n    Stream,\n} from \"../common/Exports\";\nimport { AudioStreamFormat, AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\n\nexport class FileAudioSource implements IAudioSource {\n\n    private privAudioFormatPromise: Promise<AudioStreamFormatImpl>;\n\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\n\n    private privId: string;\n\n    private privEvents: EventSource<AudioSourceEvent>;\n\n    private privSource: Blob | Buffer;\n\n    private privFilename: string;\n\n    private privHeaderEnd: number = 44;\n\n    public constructor(file: File | Buffer, filename?: string, audioSourceId?: string) {\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\n        this.privEvents = new EventSource<AudioSourceEvent>();\n        this.privSource = file;\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && this.privSource instanceof Blob) {\n            this.privFilename = (file as File).name;\n        } else {\n            this.privFilename = filename || \"unknown.wav\";\n        }\n\n        // Read the header.\n        this.privAudioFormatPromise = this.readHeader();\n    }\n\n    public get format(): Promise<AudioStreamFormatImpl> {\n        return this.privAudioFormatPromise;\n    }\n\n    public turnOn(): Promise<void> {\n        if (this.privFilename.lastIndexOf(\".wav\") !== this.privFilename.length - 4) {\n            const errorMsg = this.privFilename + \" is not supported. Only WAVE files are allowed at the moment.\";\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\n            return Promise.reject(errorMsg);\n        }\n\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n        this.onEvent(new AudioSourceReadyEvent(this.privId));\n        return;\n    }\n\n    public id(): string {\n        return this.privId;\n    }\n\n    public async attach(audioNodeId: string): Promise<IAudioStreamNode> {\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n\n        const stream: Stream<ArrayBuffer> = await this.upload(audioNodeId);\n\n        this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n        return Promise.resolve({\n            detach: async (): Promise<void> => {\n                stream.readEnded();\n                delete this.privStreams[audioNodeId];\n                this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n                await this.turnOff();\n            },\n            id: (): string => audioNodeId,\n            read: (): Promise<IStreamChunk<ArrayBuffer>> => stream.read(),\n        });\n    }\n\n    public detach(audioNodeId: string): void {\n        if (audioNodeId && this.privStreams[audioNodeId]) {\n            this.privStreams[audioNodeId].close();\n            delete this.privStreams[audioNodeId];\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n        }\n    }\n\n    public turnOff(): Promise<void> {\n        for (const streamId in this.privStreams) {\n            if (streamId) {\n                const stream = this.privStreams[streamId];\n                if (stream && !stream.isClosed) {\n                    stream.close();\n                }\n            }\n        }\n\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\n        return Promise.resolve();\n    }\n\n    public get events(): EventSource<AudioSourceEvent> {\n        return this.privEvents;\n    }\n\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\n        return this.privAudioFormatPromise.then<ISpeechConfigAudioDevice>((result: AudioStreamFormatImpl): Promise<{\n            bitspersample: number;\n            channelcount: number;\n            connectivity: connectivity.Unknown;\n            manufacturer: string;\n            model: string;\n            samplerate: number;\n            type: type.File;\n        }> => ( Promise.resolve({\n                bitspersample: result.bitsPerSample,\n                channelcount: result.channels,\n                connectivity: connectivity.Unknown,\n                manufacturer: \"Speech SDK\",\n                model: \"File\",\n                samplerate: result.samplesPerSec,\n                type: type.File,\n            })\n        ));\n    }\n\n    private readHeader(): Promise<AudioStreamFormatImpl> {\n        // Read the wave header.\n        const maxHeaderSize: number = 4296;\n        const header: Blob | Buffer = this.privSource.slice(0, maxHeaderSize);\n\n        const headerResult: Deferred<AudioStreamFormatImpl> = new Deferred<AudioStreamFormatImpl>();\n\n        const processHeader = (header: ArrayBuffer): void => {\n            const view: DataView = new DataView(header);\n\n            const getWord = (index: number): string => String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));\n\n            // RIFF 4 bytes.\n            if (\"RIFF\" !== getWord(0)) {\n                headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\n                return;\n            }\n\n            // length, 4 bytes\n            // RIFF Type & fmt 8 bytes\n            if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\n                headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\n                return;\n            }\n\n            const formatSize: number = view.getInt32(16, true);\n            const channelCount: number = view.getUint16(22, true);\n            const sampleRate: number = view.getUint32(24, true);\n            const bitsPerSample: number = view.getUint16(34, true);\n            // Confirm if header is 44 bytes long.\n            let pos: number = 36 + Math.max(formatSize - 16, 0);\n            for (; getWord(pos) !== \"data\"; pos += 2) {\n                if (pos > maxHeaderSize - 8) {\n                    headerResult.reject(\"Invalid WAV header in file, data block was not found\");\n                    return;\n                }\n            }\n            this.privHeaderEnd = pos + 8;\n            headerResult.resolve(AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount) as AudioStreamFormatImpl);\n        };\n\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && header instanceof Blob) {\n            const reader: FileReader = new FileReader();\n\n            reader.onload = (event: Event): void => {\n                const header: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\n                processHeader(header);\n            };\n\n            reader.readAsArrayBuffer(header);\n        } else {\n            const h: Buffer = header as Buffer;\n            processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));\n        }\n        return headerResult.promise;\n    }\n\n    private async upload(audioNodeId: string): Promise<Stream<ArrayBuffer>> {\n        const onerror = (error: string): void => {\n            const errorMsg = `Error occurred while processing '${this.privFilename}'. ${error}`;\n            this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\n            throw new Error(errorMsg);\n        };\n\n        try {\n            await this.turnOn();\n\n            const format: AudioStreamFormatImpl = await this.privAudioFormatPromise;\n            const stream = new ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\n\n            this.privStreams[audioNodeId] = stream;\n            const chunk: Blob | Buffer = this.privSource.slice(this.privHeaderEnd);\n\n            const processFile = (buff: ArrayBuffer): void => {\n                if (stream.isClosed) {\n                    return; // output stream was closed (somebody called TurnOff). We're done here.\n                }\n\n                stream.writeStreamChunk({\n                    buffer: buff,\n                    isEnd: false,\n                    timeReceived: Date.now(),\n                });\n                stream.close();\n            };\n\n            if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && chunk instanceof Blob) {\n                const reader: FileReader = new FileReader();\n                reader.onerror = (ev: ProgressEvent<FileReader>): void  =>  onerror(ev.toString());\n\n                reader.onload = (event: Event): void => {\n                    const fileBuffer: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\n                    processFile(fileBuffer);\n                };\n\n                reader.readAsArrayBuffer(chunk);\n            } else {\n                const c: Buffer = chunk as Buffer;\n                processFile(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));\n            }\n\n            return stream;\n        } catch (e) {\n            onerror(e as string);\n        }\n    }\n\n    private onEvent(event: AudioSourceEvent): void {\n        this.privEvents.onEvent(event);\n        Events.instance.onEvent(event);\n    }\n}\n"]}