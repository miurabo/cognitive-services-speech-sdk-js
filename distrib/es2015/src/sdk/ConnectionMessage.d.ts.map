{"version":3,"sources":["src/sdk/ConnectionMessage.ts"],"names":[],"mappings":"AAOA,OAAO,EACH,iBAAiB,IAAI,oBAAoB,EAE5C,MAAM,mBAAmB,CAAC;AAC3B,OAAO,EACH,kBAAkB,EACrB,MAAM,sBAAsB,CAAC;AAG9B;;;;;;;GAOG;AACH,8BAAsB,iBAAiB;IACnC;;OAEG;IACH,aAAoB,IAAI,IAAI,MAAM,CAAC;IAEnC;;;OAGG;IACH,aAAoB,aAAa,IAAI,OAAO,CAAC;IAE7C;;;OAGG;IACH,aAAoB,eAAe,IAAI,OAAO,CAAC;IAE/C;;;;OAIG;IACH,aAAoB,WAAW,IAAI,MAAM,CAAC;IAE1C;;OAEG;IACH,aAAoB,aAAa,IAAI,WAAW,CAAC;IAEjD;;;OAGG;IACH,aAAoB,UAAU,IAAI,kBAAkB,CAAC;IAErD;;OAEG;aACa,QAAQ,IAAI,MAAM;CACrC;AAED,qBAAa,qBAAqB;IAE9B,OAAO,CAAC,qBAAqB,CAAuB;IACpD,OAAO,CAAC,cAAc,CAAqB;gBAExB,OAAO,EAAE,oBAAoB;IAYhD;;OAEG;IACH,IAAW,IAAI,IAAI,MAAM,CAExB;IAED;;;OAGG;IACH,IAAW,aAAa,IAAI,OAAO,CAElC;IAED;;;OAGG;IACH,IAAW,eAAe,IAAI,OAAO,CAEpC;IAED;;;;OAIG;IACH,IAAW,WAAW,IAAI,MAAM,CAE/B;IAED;;OAEG;IACH,IAAW,aAAa,IAAI,WAAW,CAEtC;IAED;;;OAGG;IACH,IAAW,UAAU,IAAI,kBAAkB,CAE1C;IAED;;OAEG;IACI,QAAQ,IAAI,MAAM;CAG5B","file":"ConnectionMessage.d.ts","sourcesContent":["//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\n\n// eslint-disable-next-line max-classes-per-file\nimport { HeaderNames } from \"../common.speech/HeaderNames\";\nimport {\n    ConnectionMessage as IntConnectionMessage,\n    MessageType\n} from \"../common/Exports\";\nimport {\n    PropertyCollection\n} from \"./PropertyCollection\";\nimport { PropertyId } from \"./PropertyId\";\n\n/**\n * ConnectionMessage represents implementation specific messages sent to and received from\n * the speech service. These messages are provided for debugging purposes and should not\n * be used for production use cases with the Azure Cognitive Services Speech Service.\n * Messages sent to and received from the Speech Service are subject to change without\n * notice. This includes message contents, headers, payloads, ordering, etc.\n * Added in version 1.11.0.\n */\nexport abstract class ConnectionMessage {\n    /**\n     * The message path.\n     */\n    public abstract get path(): string;\n\n    /**\n     * Checks to see if the ConnectionMessage is a text message.\n     * See also IsBinaryMessage().\n     */\n    public abstract get isTextMessage(): boolean;\n\n    /**\n     * Checks to see if the ConnectionMessage is a binary message.\n     * See also GetBinaryMessage().\n     */\n    public abstract get isBinaryMessage(): boolean;\n\n    /**\n     * Gets the text message payload. Typically the text message content-type is\n     * application/json. To determine other content-types use\n     * Properties.GetProperty(\"Content-Type\").\n     */\n    public abstract get TextMessage(): string;\n\n    /**\n     * Gets the binary message payload.\n     */\n    public abstract get binaryMessage(): ArrayBuffer;\n\n    /**\n     * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\n     * Message headers can be accessed via this collection (e.g. \"Content-Type\").\n     */\n    public abstract get properties(): PropertyCollection;\n\n    /**\n     * Returns a string that represents the connection message.\n     */\n    public abstract toString(): string;\n}\n\nexport class ConnectionMessageImpl {\n\n    private privConnectionMessage: IntConnectionMessage;\n    private privProperties: PropertyCollection;\n\n    public constructor(message: IntConnectionMessage) {\n        this.privConnectionMessage = message;\n        this.privProperties = new PropertyCollection();\n        if (!!this.privConnectionMessage.headers[HeaderNames.ConnectionId]) {\n            this.privProperties.setProperty(PropertyId.Speech_SessionId, this.privConnectionMessage.headers[HeaderNames.ConnectionId]);\n        }\n\n        Object.keys(this.privConnectionMessage.headers).forEach((header: string): void => {\n            this.privProperties.setProperty(header, this.privConnectionMessage.headers[header]);\n        });\n    }\n\n    /**\n     * The message path.\n     */\n    public get path(): string {\n        return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find((key: string): boolean => key.toLowerCase() === \"path\".toLowerCase())];\n    }\n\n    /**\n     * Checks to see if the ConnectionMessage is a text message.\n     * See also IsBinaryMessage().\n     */\n    public get isTextMessage(): boolean {\n        return this.privConnectionMessage.messageType === MessageType.Text;\n    }\n\n    /**\n     * Checks to see if the ConnectionMessage is a binary message.\n     * See also GetBinaryMessage().\n     */\n    public get isBinaryMessage(): boolean {\n        return this.privConnectionMessage.messageType === MessageType.Binary;\n    }\n\n    /**\n     * Gets the text message payload. Typically the text message content-type is\n     * application/json. To determine other content-types use\n     * Properties.GetProperty(\"Content-Type\").\n     */\n    public get TextMessage(): string {\n        return this.privConnectionMessage.textBody;\n    }\n\n    /**\n     * Gets the binary message payload.\n     */\n    public get binaryMessage(): ArrayBuffer {\n        return this.privConnectionMessage.binaryBody;\n    }\n\n    /**\n     * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\n     * Message headers can be accessed via this collection (e.g. \"Content-Type\").\n     */\n    public get properties(): PropertyCollection {\n        return this.privProperties;\n    }\n\n    /**\n     * Returns a string that represents the connection message.\n     */\n    public toString(): string {\n        return \"\";\n    }\n}\n"]}