{"version":3,"sources":["src/sdk/Audio/AudioInputStream.ts"],"names":[],"mappings":"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","file":"AudioInputStream.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\n/* eslint-disable max-classes-per-file */\n\nimport {\n    connectivity,\n    ISpeechConfigAudioDevice,\n    type,\n} from \"../../common.speech/Exports\";\nimport {\n    AudioSourceEvent,\n    AudioSourceInitializingEvent,\n    AudioSourceReadyEvent,\n    AudioStreamNodeAttachedEvent,\n    AudioStreamNodeAttachingEvent,\n    AudioStreamNodeDetachedEvent,\n    ChunkedArrayBufferStream,\n    Events,\n    EventSource,\n    IAudioSource,\n    IAudioStreamNode,\n    IStreamChunk,\n    Stream,\n} from \"../../common/Exports\";\nimport { createNoDashGuid } from \"../../common/Guid\";\nimport { AudioStreamFormat, PullAudioInputStreamCallback } from \"../Exports\";\nimport { AudioStreamFormatImpl } from \"./AudioStreamFormat\";\n\n/**\n * Represents audio input stream used for custom audio input configurations.\n * @class AudioInputStream\n */\nexport abstract class AudioInputStream {\n\n    /**\n     * Creates and initializes an instance.\n     * @constructor\n     */\n    protected constructor() {\n        return;\n    }\n\n    /**\n     * Creates a memory backed PushAudioInputStream with the specified audio format.\n     * @member AudioInputStream.createPushStream\n     * @function\n     * @public\n     * @param {AudioStreamFormat} format - The audio data format in which audio will be\n     * written to the push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).\n     * @returns {PushAudioInputStream} The audio input stream being created.\n     */\n    public static createPushStream(format?: AudioStreamFormat): PushAudioInputStream {\n        return PushAudioInputStream.create(format);\n    }\n\n    /**\n     * Creates a PullAudioInputStream that delegates to the specified callback interface for read()\n     * and close() methods.\n     * @member AudioInputStream.createPullStream\n     * @function\n     * @public\n     * @param {PullAudioInputStreamCallback} callback - The custom audio input object, derived from\n     * PullAudioInputStreamCallback\n     * @param {AudioStreamFormat} format - The audio data format in which audio will be returned from\n     * the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).\n     * @returns {PullAudioInputStream} The audio input stream being created.\n     */\n    public static createPullStream(callback: PullAudioInputStreamCallback, format?: AudioStreamFormat): PullAudioInputStream {\n        return PullAudioInputStream.create(callback, format);\n        // throw new Error(\"Oops\");\n    }\n\n    /**\n     * Explicitly frees any external resource attached to the object\n     * @member AudioInputStream.prototype.close\n     * @function\n     * @public\n     */\n    public abstract close(): void;\n}\n\n/**\n * Represents memory backed push audio input stream used for custom audio input configurations.\n * @class PushAudioInputStream\n */\nexport abstract class PushAudioInputStream extends AudioInputStream {\n\n    /**\n     * Creates a memory backed PushAudioInputStream with the specified audio format.\n     * @member PushAudioInputStream.create\n     * @function\n     * @public\n     * @param {AudioStreamFormat} format - The audio data format in which audio will be written to the\n     * push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).\n     * @returns {PushAudioInputStream} The push audio input stream being created.\n     */\n    public static create(format?: AudioStreamFormat): PushAudioInputStream {\n        return new PushAudioInputStreamImpl(format);\n    }\n\n    /**\n     * Writes the audio data specified by making an internal copy of the data.\n     * @member PushAudioInputStream.prototype.write\n     * @function\n     * @public\n     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.\n     */\n    public abstract write(dataBuffer: ArrayBuffer): void;\n\n    /**\n     * Closes the stream.\n     * @member PushAudioInputStream.prototype.close\n     * @function\n     * @public\n     */\n    public abstract close(): void;\n}\n\n/**\n * Represents memory backed push audio input stream used for custom audio input configurations.\n * @private\n * @class PushAudioInputStreamImpl\n */\nexport class PushAudioInputStreamImpl extends PushAudioInputStream implements IAudioSource {\n\n    private privFormat: AudioStreamFormatImpl;\n    private privId: string;\n    private privEvents: EventSource<AudioSourceEvent>;\n    private privStream: Stream<ArrayBuffer>;\n\n    /**\n     * Creates and initalizes an instance with the given values.\n     * @constructor\n     * @param {AudioStreamFormat} format - The audio stream format.\n     */\n    public constructor(format?: AudioStreamFormat) {\n        super();\n        if (format === undefined) {\n            this.privFormat = AudioStreamFormatImpl.getDefaultInputFormat();\n        } else {\n            this.privFormat = format as AudioStreamFormatImpl;\n        }\n        this.privEvents = new EventSource<AudioSourceEvent>();\n        this.privId = createNoDashGuid();\n        this.privStream = new ChunkedArrayBufferStream(this.privFormat.avgBytesPerSec / 10);\n    }\n\n    /**\n     * Format information for the audio\n     */\n    public get format(): Promise<AudioStreamFormatImpl> {\n        return Promise.resolve(this.privFormat);\n    }\n\n    /**\n     * Writes the audio data specified by making an internal copy of the data.\n     * @member PushAudioInputStreamImpl.prototype.write\n     * @function\n     * @public\n     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.\n     */\n    public write(dataBuffer: ArrayBuffer): void {\n        this.privStream.writeStreamChunk({\n            buffer: dataBuffer,\n            isEnd: false,\n            timeReceived: Date.now()\n        });\n    }\n\n    /**\n     * Closes the stream.\n     * @member PushAudioInputStreamImpl.prototype.close\n     * @function\n     * @public\n     */\n    public close(): void {\n        this.privStream.close();\n    }\n\n    public id(): string {\n        return this.privId;\n    }\n\n    public turnOn(): Promise<void> {\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n        this.onEvent(new AudioSourceReadyEvent(this.privId));\n        return;\n    }\n\n    public async attach(audioNodeId: string): Promise<IAudioStreamNode> {\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n\n        await this.turnOn();\n        const stream = this.privStream;\n        this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n        return {\n            detach: async (): Promise<void> => {\n                this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n                return this.turnOff();\n            },\n            id: (): string => audioNodeId,\n            read: (): Promise<IStreamChunk<ArrayBuffer>> => stream.read(),\n        };\n    }\n\n    public detach(audioNodeId: string): void {\n        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n    }\n\n    public turnOff(): Promise<void> {\n        return;\n    }\n\n    public get events(): EventSource<AudioSourceEvent> {\n        return this.privEvents;\n    }\n\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\n        return Promise.resolve({\n            bitspersample: this.privFormat.bitsPerSample,\n            channelcount: this.privFormat.channels,\n            connectivity: connectivity.Unknown,\n            manufacturer: \"Speech SDK\",\n            model: \"PushStream\",\n            samplerate: this.privFormat.samplesPerSec,\n            type: type.Stream,\n        });\n    }\n\n    private onEvent(event: AudioSourceEvent): void {\n        this.privEvents.onEvent(event);\n        Events.instance.onEvent(event);\n    }\n\n    private toBuffer(arrayBuffer: ArrayBuffer): Buffer {\n        const buf: Buffer = Buffer.alloc(arrayBuffer.byteLength);\n        const view: Uint8Array = new Uint8Array(arrayBuffer);\n        for (let i = 0; i < buf.length; ++i) {\n            buf[i] = view[i];\n        }\n        return buf;\n    }\n}\n\n/*\n * Represents audio input stream used for custom audio input configurations.\n * @class PullAudioInputStream\n */\nexport abstract class PullAudioInputStream extends AudioInputStream {\n    /**\n     * Creates and initializes and instance.\n     * @constructor\n     */\n    protected constructor() {\n super();\n}\n\n    /**\n     * Creates a PullAudioInputStream that delegates to the specified callback interface for\n     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).\n     * @member PullAudioInputStream.create\n     * @function\n     * @public\n     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,\n     * derived from PullAudioInputStreamCustomCallback\n     * @param {AudioStreamFormat} format - The audio data format in which audio will be\n     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).\n     * @returns {PullAudioInputStream} The push audio input stream being created.\n     */\n    public static create(callback: PullAudioInputStreamCallback, format?: AudioStreamFormat): PullAudioInputStream {\n        return new PullAudioInputStreamImpl(callback, format as AudioStreamFormatImpl);\n    }\n\n    /**\n     * Explicitly frees any external resource attached to the object\n     * @member PullAudioInputStream.prototype.close\n     * @function\n     * @public\n     */\n    public abstract close(): void;\n\n}\n\n/**\n * Represents audio input stream used for custom audio input configurations.\n * @private\n * @class PullAudioInputStreamImpl\n */\nexport class PullAudioInputStreamImpl extends PullAudioInputStream implements IAudioSource {\n\n    private privCallback: PullAudioInputStreamCallback;\n    private privFormat: AudioStreamFormatImpl;\n    private privId: string;\n    private privEvents: EventSource<AudioSourceEvent>;\n    private privIsClosed: boolean;\n    private privBufferSize: number;\n\n    /**\n     * Creates a PullAudioInputStream that delegates to the specified callback interface for\n     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).\n     * @constructor\n     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,\n     * derived from PullAudioInputStreamCustomCallback\n     * @param {AudioStreamFormat} format - The audio data format in which audio will be\n     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).\n     */\n    public constructor(callback: PullAudioInputStreamCallback, format?: AudioStreamFormatImpl) {\n        super();\n        if (undefined === format) {\n            this.privFormat = AudioStreamFormat.getDefaultInputFormat() as AudioStreamFormatImpl;\n        } else {\n            this.privFormat = format;\n        }\n        this.privEvents = new EventSource<AudioSourceEvent>();\n        this.privId = createNoDashGuid();\n        this.privCallback = callback;\n        this.privIsClosed = false;\n        this.privBufferSize = this.privFormat.avgBytesPerSec / 10;\n    }\n\n    /**\n     * Format information for the audio\n     */\n    public get format(): Promise<AudioStreamFormatImpl> {\n        return Promise.resolve(this.privFormat);\n    }\n\n    /**\n     * Closes the stream.\n     * @member PullAudioInputStreamImpl.prototype.close\n     * @function\n     * @public\n     */\n    public close(): void {\n        this.privIsClosed = true;\n        this.privCallback.close();\n    }\n\n    public id(): string {\n        return this.privId;\n    }\n\n    public turnOn(): Promise<void> {\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n        this.onEvent(new AudioSourceReadyEvent(this.privId));\n        return;\n    }\n\n    public async attach(audioNodeId: string): Promise<IAudioStreamNode> {\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n\n        await this.turnOn();\n        this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n        return {\n            detach: (): Promise<void> => {\n                this.privCallback.close();\n                this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n                return this.turnOff();\n            },\n            id: (): string => audioNodeId,\n            read: (): Promise<IStreamChunk<ArrayBuffer>> => {\n                let totalBytes: number = 0;\n                let transmitBuff: ArrayBuffer;\n                // Until we have the minimum number of bytes to send in a transmission, keep asking for more.\n                while (totalBytes < this.privBufferSize) {\n                    // Sizing the read buffer to the delta between the perfect size and what's left means we won't ever get too much\n                    // data back.\n                    const readBuff: ArrayBuffer = new ArrayBuffer(this.privBufferSize - totalBytes);\n                    const pulledBytes: number = this.privCallback.read(readBuff);\n                    // If there is no return buffer yet defined, set the return buffer to the that was just populated.\n                    // This was, if we have enough data there's no copy penalty, but if we don't we have a buffer that's the\n                    // preferred size allocated.\n                    if (undefined === transmitBuff) {\n                        transmitBuff = readBuff;\n                    } else {\n                        // Not the first bite at the apple, so fill the return buffer with the data we got back.\n                        const intView: Int8Array = new Int8Array(transmitBuff);\n                        intView.set(new Int8Array(readBuff), totalBytes);\n                    }\n                    // If there are no bytes to read, just break out and be done.\n                    if (0 === pulledBytes) {\n                        break;\n                    }\n                    totalBytes += pulledBytes;\n                }\n                return Promise.resolve<IStreamChunk<ArrayBuffer>>({\n                    buffer: transmitBuff.slice(0, totalBytes),\n                    isEnd: this.privIsClosed || totalBytes === 0,\n                    timeReceived: Date.now(),\n                });\n            },\n        };\n    }\n\n    public detach(audioNodeId: string): void {\n        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n    }\n\n    public turnOff(): Promise<void> {\n        return;\n    }\n\n    public get events(): EventSource<AudioSourceEvent> {\n        return this.privEvents;\n    }\n\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\n        return Promise.resolve({\n            bitspersample: this.privFormat.bitsPerSample,\n            channelcount: this.privFormat.channels,\n            connectivity: connectivity.Unknown,\n            manufacturer: \"Speech SDK\",\n            model: \"PullStream\",\n            samplerate: this.privFormat.samplesPerSec,\n            type: type.Stream,\n        });\n    }\n\n    private onEvent(event: AudioSourceEvent): void {\n        this.privEvents.onEvent(event);\n        Events.instance.onEvent(event);\n    }\n}\n"]}