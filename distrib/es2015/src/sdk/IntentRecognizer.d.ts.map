{"version":3,"sources":["src/sdk/IntentRecognizer.ts"],"names":[],"mappings":"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","file":"IntentRecognizer.d.ts","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport {\n    AddedLmIntent,\n    IAuthentication,\n    IConnectionFactory,\n    IntentConnectionFactory,\n    IntentServiceRecognizer,\n    RecognitionMode,\n    RecognizerConfig,\n    ServiceRecognizerBase,\n    SpeechServiceConfig\n} from \"../common.speech/Exports\";\nimport { marshalPromiseToCallbacks } from \"../common/Exports\";\nimport { AudioConfigImpl } from \"./Audio/AudioConfig\";\nimport { Contracts } from \"./Contracts\";\nimport {\n    AudioConfig,\n    IntentRecognitionCanceledEventArgs,\n    IntentRecognitionEventArgs,\n    IntentRecognitionResult,\n    KeywordRecognitionModel,\n    LanguageUnderstandingModel,\n    PropertyCollection,\n    PropertyId,\n    Recognizer,\n    SpeechConfig,\n} from \"./Exports\";\nimport { LanguageUnderstandingModelImpl } from \"./LanguageUnderstandingModel\";\nimport { SpeechConfigImpl } from \"./SpeechConfig\";\n\n/**\n * Intent recognizer.\n * @class\n */\nexport class IntentRecognizer extends Recognizer {\n    private privDisposedIntentRecognizer: boolean;\n    private privAddedIntents: string[][];\n    private privAddedLmIntents: { [id: string]: AddedLmIntent };\n    private privUmbrellaIntent: AddedLmIntent;\n\n    /**\n     * Initializes an instance of the IntentRecognizer.\n     * @constructor\n     * @param {SpeechConfig} speechConfig - The set of configuration properties.\n     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer\n     */\n    public constructor(speechConfig: SpeechConfig, audioConfig?: AudioConfig) {\n        Contracts.throwIfNullOrUndefined(speechConfig, \"speechConfig\");\n        const configImpl: SpeechConfigImpl = speechConfig as SpeechConfigImpl;\n        Contracts.throwIfNullOrUndefined(configImpl, \"speechConfig\");\n\n        super(audioConfig, configImpl.properties, new IntentConnectionFactory());\n        this.privAddedIntents = [];\n        this.privAddedLmIntents = {};\n\n        this.privDisposedIntentRecognizer = false;\n        this.privProperties = configImpl.properties;\n\n        Contracts.throwIfNullOrWhitespace(this.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage), PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n    }\n\n    /**\n     * The event recognizing signals that an intermediate recognition result is received.\n     * @member IntentRecognizer.prototype.recognizing\n     * @function\n     * @public\n     */\n    public recognizing: (sender: IntentRecognizer, event: IntentRecognitionEventArgs) => void;\n\n    /**\n     * The event recognized signals that a final recognition result is received.\n     * @member IntentRecognizer.prototype.recognized\n     * @function\n     * @public\n     */\n    public recognized: (sender: IntentRecognizer, event: IntentRecognitionEventArgs) => void;\n\n    /**\n     * The event canceled signals that an error occurred during recognition.\n     * @member IntentRecognizer.prototype.canceled\n     * @function\n     * @public\n     */\n    public canceled: (sender: IntentRecognizer, event: IntentRecognitionCanceledEventArgs) => void;\n\n    /**\n     * Gets the spoken language of recognition.\n     * @member IntentRecognizer.prototype.speechRecognitionLanguage\n     * @function\n     * @public\n     * @returns {string} the spoken language of recognition.\n     */\n    public get speechRecognitionLanguage(): string {\n        Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);\n\n        return this.properties.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage);\n    }\n\n    /**\n     * Gets the authorization token used to communicate with the service.\n     * @member IntentRecognizer.prototype.authorizationToken\n     * @function\n     * @public\n     * @returns {string} Authorization token.\n     */\n    public get authorizationToken(): string {\n        return this.properties.getProperty(PropertyId.SpeechServiceAuthorization_Token);\n    }\n\n    /**\n     * Gets/Sets the authorization token used to communicate with the service.\n     * Note: Please use a token derived from your LanguageUnderstanding subscription key for the Intent recognizer.\n     * @member IntentRecognizer.prototype.authorizationToken\n     * @function\n     * @public\n     * @param {string} value - Authorization token.\n     */\n    public set authorizationToken(value: string) {\n        this.properties.setProperty(PropertyId.SpeechServiceAuthorization_Token, value);\n    }\n\n    /**\n     * The collection of properties and their values defined for this IntentRecognizer.\n     * @member IntentRecognizer.prototype.properties\n     * @function\n     * @public\n     * @returns {PropertyCollection} The collection of properties and their\n     * values defined for this IntentRecognizer.\n     */\n    public get properties(): PropertyCollection {\n        return this.privProperties;\n    }\n\n    /**\n     * Starts intent recognition, and stops after the first utterance is recognized.\n     * The task returns the recognition text and intent as result.\n     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,\n     * so it is suitable only for single shot recognition like command or query.\n     * For long-running recognition, use StartContinuousRecognitionAsync() instead.\n     * @member IntentRecognizer.prototype.recognizeOnceAsync\n     * @function\n     * @public\n     * @param cb - Callback that received the recognition has finished with an IntentRecognitionResult.\n     * @param err - Callback invoked in case of an error.\n     */\n    public recognizeOnceAsync(cb?: (e: IntentRecognitionResult) => void, err?: (e: string) => void): void {\n        Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);\n\n        if (Object.keys(this.privAddedLmIntents).length !== 0 || undefined !== this.privUmbrellaIntent) {\n            const context: IIntentContext = this.buildSpeechContext();\n\n            this.privReco.speechContext.setSection(\"intent\", context.Intent);\n            this.privReco.dynamicGrammar.addReferenceGrammar(context.ReferenceGrammars);\n\n            const intentReco: IntentServiceRecognizer = this.privReco as IntentServiceRecognizer;\n            intentReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);\n        }\n\n        marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(RecognitionMode.Interactive), cb, err);\n    }\n\n    /**\n     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.\n     * User must subscribe to events to receive recognition results.\n     * @member IntentRecognizer.prototype.startContinuousRecognitionAsync\n     * @function\n     * @public\n     * @param cb - Callback invoked once the recognition has started.\n     * @param err - Callback invoked in case of an error.\n     */\n    public startContinuousRecognitionAsync(cb?: () => void, err?: (e: string) => void): void {\n        if (Object.keys(this.privAddedLmIntents).length !== 0 || undefined !== this.privUmbrellaIntent) {\n            const context: IIntentContext = this.buildSpeechContext();\n\n            this.privReco.speechContext.setSection(\"intent\", context.Intent);\n            this.privReco.dynamicGrammar.addReferenceGrammar(context.ReferenceGrammars);\n\n            const intentReco: IntentServiceRecognizer = this.privReco as IntentServiceRecognizer;\n            intentReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);\n        }\n\n        marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(RecognitionMode.Conversation), cb, err);\n    }\n\n    /**\n     * Stops continuous intent recognition.\n     * @member IntentRecognizer.prototype.stopContinuousRecognitionAsync\n     * @function\n     * @public\n     * @param cb - Callback invoked once the recognition has stopped.\n     * @param err - Callback invoked in case of an error.\n     */\n    public stopContinuousRecognitionAsync(cb?: () => void, err?: (e: string) => void): void {\n        marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);\n    }\n\n    /**\n     * Starts speech recognition with keyword spotting, until stopKeywordRecognitionAsync() is called.\n     * User must subscribe to events to receive recognition results.\n     * Note: Key word spotting functionality is only available on the Speech Devices SDK.\n     * This functionality is currently not included in the SDK itself.\n     * @member IntentRecognizer.prototype.startKeywordRecognitionAsync\n     * @function\n     * @public\n     * @param {KeywordRecognitionModel} model - The keyword recognition model that specifies the keyword to be recognized.\n     * @param cb - Callback invoked once the recognition has started.\n     * @param err - Callback invoked in case of an error.\n     */\n    public startKeywordRecognitionAsync(model: KeywordRecognitionModel, cb?: () => void, err?: (e: string) => void): void {\n        Contracts.throwIfNull(model, \"model\");\n\n        if (!!err) {\n            err(\"Not yet implemented.\");\n        }\n    }\n\n    /**\n     * Stops continuous speech recognition.\n     * Note: Key word spotting functionality is only available on the Speech Devices SDK.\n     * This functionality is currently not included in the SDK itself.\n     * @member IntentRecognizer.prototype.stopKeywordRecognitionAsync\n     * @function\n     * @public\n     * @param cb - Callback invoked once the recognition has stopped.\n     * @param err - Callback invoked in case of an error.\n     */\n    public stopKeywordRecognitionAsync(cb?: () => void, err?: (e: string) => void): void {\n        if (!!cb) {\n            try {\n                cb();\n            } catch (e) {\n                if (!!err) {\n                    err(e as string);\n                }\n            }\n        }\n    }\n\n    /**\n     * Adds a phrase that should be recognized as intent.\n     * @member IntentRecognizer.prototype.addIntent\n     * @function\n     * @public\n     * @param {string} intentId - A String that represents the identifier of the intent to be recognized.\n     * @param {string} phrase - A String that specifies the phrase representing the intent.\n     */\n    public addIntent(simplePhrase: string, intentId?: string): void {\n        Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);\n        Contracts.throwIfNullOrWhitespace(intentId, \"intentId\");\n        Contracts.throwIfNullOrWhitespace(simplePhrase, \"simplePhrase\");\n\n        this.privAddedIntents.push([intentId, simplePhrase]);\n    }\n\n    /**\n     * Adds an intent from Language Understanding service for recognition.\n     * @member IntentRecognizer.prototype.addIntentWithLanguageModel\n     * @function\n     * @public\n     * @param {string} intentId - A String that represents the identifier of the intent\n     * to be recognized. Ignored if intentName is empty.\n     * @param {string} model - The intent model from Language Understanding service.\n     * @param {string} intentName - The intent name defined in the intent model. If it\n     * is empty, all intent names defined in the model will be added.\n     */\n    public addIntentWithLanguageModel(intentId: string, model: LanguageUnderstandingModel, intentName?: string): void {\n        Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);\n        Contracts.throwIfNullOrWhitespace(intentId, \"intentId\");\n        Contracts.throwIfNull(model, \"model\");\n\n        const modelImpl: LanguageUnderstandingModelImpl = model as LanguageUnderstandingModelImpl;\n        Contracts.throwIfNullOrWhitespace(modelImpl.appId, \"model.appId\");\n\n        this.privAddedLmIntents[intentId] = new AddedLmIntent(modelImpl, intentName);\n    }\n\n    /**\n     * @summary Adds all intents from the specified Language Understanding Model.\n     * @member IntentRecognizer.prototype.addAllIntents\n     * @function\n     * @public\n     * @function\n     * @public\n     * @param {LanguageUnderstandingModel} model - The language understanding model containing the intents.\n     * @param {string} intentId - A custom id String to be returned in the IntentRecognitionResult's getIntentId() method.\n     */\n    public addAllIntents(model: LanguageUnderstandingModel, intentId?: string): void {\n        Contracts.throwIfNull(model, \"model\");\n\n        const modelImpl: LanguageUnderstandingModelImpl = model as LanguageUnderstandingModelImpl;\n        Contracts.throwIfNullOrWhitespace(modelImpl.appId, \"model.appId\");\n\n        this.privUmbrellaIntent = new AddedLmIntent(modelImpl, intentId);\n    }\n\n    /**\n     * closes all external resources held by an instance of this class.\n     * @member IntentRecognizer.prototype.close\n     * @function\n     * @public\n     */\n    public close(cb?: () => void, errorCb?: (error: string) => void): void {\n        Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);\n\n        marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);\n    }\n\n    protected createRecognizerConfig(speechConfig: SpeechServiceConfig): RecognizerConfig {\n        return new RecognizerConfig(speechConfig, this.privProperties);\n    }\n\n    protected createServiceRecognizer(authentication: IAuthentication, connectionFactory: IConnectionFactory, audioConfig: AudioConfig, recognizerConfig: RecognizerConfig): ServiceRecognizerBase {\n        const audioImpl: AudioConfigImpl = audioConfig as AudioConfigImpl;\n        return new IntentServiceRecognizer(authentication, connectionFactory, audioImpl, recognizerConfig, this);\n    }\n\n    protected async dispose(disposing: boolean): Promise<void> {\n        if (this.privDisposedIntentRecognizer) {\n            return;\n        }\n\n        if (disposing) {\n            this.privDisposedIntentRecognizer = true;\n            await super.dispose(disposing);\n        }\n    }\n\n    private buildSpeechContext(): IIntentContext {\n        let appId: string;\n        let region: string;\n        let subscriptionKey: string;\n        const refGrammers: string[] = [];\n\n        if (undefined !== this.privUmbrellaIntent) {\n            appId = this.privUmbrellaIntent.modelImpl.appId;\n            region = this.privUmbrellaIntent.modelImpl.region;\n            subscriptionKey = this.privUmbrellaIntent.modelImpl.subscriptionKey;\n        }\n\n        // Build the reference grammer array.\n        for (const intentId of Object.keys(this.privAddedLmIntents)) {\n            const addedLmIntent: AddedLmIntent = this.privAddedLmIntents[intentId];\n\n            // validate all the same model, region, and key...\n            if (appId === undefined) {\n                appId = addedLmIntent.modelImpl.appId;\n            } else {\n                if (appId !== addedLmIntent.modelImpl.appId) {\n                    throw new Error(\"Intents must all be from the same LUIS model\");\n                }\n            }\n\n            if (region === undefined) {\n                region = addedLmIntent.modelImpl.region;\n            } else {\n                if (region !== addedLmIntent.modelImpl.region) {\n                    throw new Error(\"Intents must all be from the same LUIS model in a single region\");\n                }\n            }\n\n            if (subscriptionKey === undefined) {\n                subscriptionKey = addedLmIntent.modelImpl.subscriptionKey;\n            } else {\n                if (subscriptionKey !== addedLmIntent.modelImpl.subscriptionKey) {\n                    throw new Error(\"Intents must all use the same subscription key\");\n                }\n            }\n\n            const grammer: string = \"luis/\" + appId + \"-PRODUCTION#\" + intentId;\n            refGrammers.push(grammer);\n        }\n\n        return {\n            Intent: {\n                id: appId,\n                key: (subscriptionKey === undefined) ? this.privProperties.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Key]) : subscriptionKey,\n                provider: \"LUIS\",\n            },\n            ReferenceGrammars: (undefined === this.privUmbrellaIntent) ? refGrammers : [\"luis/\" + appId + \"-PRODUCTION\"],\n        };\n    }\n}\n\ninterface IIntentContext {\n    Intent: {\n        id: string;\n        key: string;\n        provider: string;\n    };\n    ReferenceGrammars: string[];\n}\n"]}