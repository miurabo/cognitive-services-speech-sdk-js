{"version":3,"sources":["src/common/ChunkedArrayBufferStream.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,YAAY,EAAE,MAAM,EAAE,MAAM,WAAW,CAAC;AAEjD,qBAAa,wBAAyB,SAAQ,MAAM,CAAC,WAAW,CAAC;IAC7D,OAAO,CAAC,mBAAmB,CAAS;IACpC,OAAO,CAAC,qBAAqB,CAAc;IAC3C,OAAO,CAAC,uBAAuB,CAAS;IACxC,OAAO,CAAC,wBAAwB,CAAS;gBAEtB,eAAe,EAAE,MAAM,EAAE,QAAQ,CAAC,EAAE,MAAM;IAMtD,gBAAgB,CAAC,KAAK,EAAE,YAAY,CAAC,WAAW,CAAC,GAAG,IAAI;IAuCxD,KAAK,IAAI,IAAI;CAYvB","file":"ChunkedArrayBufferStream.d.ts","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport { IStreamChunk, Stream } from \"./Exports\";\n\nexport class ChunkedArrayBufferStream extends Stream<ArrayBuffer> {\n    private privTargetChunkSize: number;\n    private privNextBufferToWrite: ArrayBuffer;\n    private privNextBufferStartTime: number;\n    private privNextBufferReadyBytes: number;\n\n    public constructor(targetChunkSize: number, streamId?: string) {\n        super(streamId);\n        this.privTargetChunkSize = targetChunkSize;\n        this.privNextBufferReadyBytes = 0;\n    }\n\n    public writeStreamChunk(chunk: IStreamChunk<ArrayBuffer>): void {\n        // No pending write, and the buffer is the right size so write it.\n        if (chunk.isEnd ||\n            (0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize)) {\n            super.writeStreamChunk(chunk);\n            return;\n        }\n\n        let bytesCopiedFromBuffer: number = 0;\n\n        while (bytesCopiedFromBuffer < chunk.buffer.byteLength) {\n            // Fill the next buffer.\n            if (undefined === this.privNextBufferToWrite) {\n                this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize);\n                this.privNextBufferStartTime = chunk.timeReceived;\n            }\n\n            // Find out how many bytes we can copy into the read buffer.\n            const bytesToCopy: number = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes);\n            const targetView: Uint8Array = new Uint8Array(this.privNextBufferToWrite);\n            const sourceView: Uint8Array = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));\n\n            targetView.set(sourceView, this.privNextBufferReadyBytes);\n            this.privNextBufferReadyBytes += bytesToCopy;\n            bytesCopiedFromBuffer += bytesToCopy;\n\n            // Are we ready to write?\n            if (this.privNextBufferReadyBytes === this.privTargetChunkSize) {\n                super.writeStreamChunk({\n                    buffer: this.privNextBufferToWrite,\n                    isEnd: false,\n                    timeReceived: this.privNextBufferStartTime,\n                });\n                this.privNextBufferReadyBytes = 0;\n                this.privNextBufferToWrite = undefined;\n            }\n        }\n    }\n\n    public close(): void {\n        // Send whatever is pending, then close the base class.\n        if (0 !== this.privNextBufferReadyBytes && !this.isClosed) {\n            super.writeStreamChunk({\n                buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),\n                isEnd: false,\n                timeReceived: this.privNextBufferStartTime,\n            });\n        }\n\n        super.close();\n    }\n}\n"]}