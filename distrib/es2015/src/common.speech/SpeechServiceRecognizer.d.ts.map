{"version":3,"sources":["src/common.speech/SpeechServiceRecognizer.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,YAAY,EAAE,MAAM,mBAAmB,CAAC;AACjD,OAAO,EACH,qBAAqB,EACrB,kBAAkB,EAQlB,gBAAgB,EACnB,MAAM,gBAAgB,CAAC;AACxB,OAAO,EAMH,qBAAqB,EAGxB,MAAM,WAAW,CAAC;AACnB,OAAO,EAAE,eAAe,EAAE,MAAM,mBAAmB,CAAC;AACpD,OAAO,EAAE,kBAAkB,EAAE,MAAM,sBAAsB,CAAC;AAC1D,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AACtD,OAAO,EAAE,uBAAuB,EAAE,MAAM,oCAAoC,CAAC;AAG7E,qBAAa,uBAAwB,SAAQ,qBAAqB;IAE9D,OAAO,CAAC,oBAAoB,CAAmB;gBAG3C,cAAc,EAAE,eAAe,EAC/B,iBAAiB,EAAE,kBAAkB,EACrC,WAAW,EAAE,YAAY,EACzB,gBAAgB,EAAE,gBAAgB,EAClC,gBAAgB,EAAE,gBAAgB;cAMtB,2BAA2B,CAAC,iBAAiB,EAAE,uBAAuB,GAAG,OAAO,CAAC,OAAO,CAAC;IA+HzG,SAAS,CAAC,iBAAiB,CACvB,SAAS,EAAE,MAAM,EACjB,SAAS,EAAE,MAAM,EACjB,kBAAkB,EAAE,kBAAkB,EACtC,SAAS,EAAE,qBAAqB,EAChC,KAAK,EAAE,MAAM,GAAG,IAAI;CAsC3B","file":"SpeechServiceRecognizer.d.ts","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport { IAudioSource } from \"../common/Exports\";\nimport {\n    CancellationErrorCode,\n    CancellationReason,\n    OutputFormat,\n    PropertyCollection,\n    PropertyId,\n    ResultReason,\n    SpeechRecognitionCanceledEventArgs,\n    SpeechRecognitionEventArgs,\n    SpeechRecognitionResult,\n    SpeechRecognizer,\n} from \"../sdk/Exports\";\nimport {\n    CancellationErrorCodePropertyName,\n    DetailedSpeechPhrase,\n    EnumTranslation,\n    OutputFormatPropertyName,\n    RecognitionStatus,\n    ServiceRecognizerBase,\n    SimpleSpeechPhrase,\n    SpeechHypothesis,\n} from \"./Exports\";\nimport { IAuthentication } from \"./IAuthentication\";\nimport { IConnectionFactory } from \"./IConnectionFactory\";\nimport { RecognizerConfig } from \"./RecognizerConfig\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\n\n// eslint-disable-next-line max-classes-per-file\nexport class SpeechServiceRecognizer extends ServiceRecognizerBase {\n\n    private privSpeechRecognizer: SpeechRecognizer;\n\n    public constructor(\n        authentication: IAuthentication,\n        connectionFactory: IConnectionFactory,\n        audioSource: IAudioSource,\n        recognizerConfig: RecognizerConfig,\n        speechRecognizer: SpeechRecognizer) {\n        super(authentication, connectionFactory, audioSource, recognizerConfig, speechRecognizer);\n        this.privSpeechRecognizer = speechRecognizer;\n\n    }\n\n    protected async processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\n\n        let result: SpeechRecognitionResult;\n        const resultProps: PropertyCollection = new PropertyCollection();\n        resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n        let processed: boolean = false;\n\n        switch (connectionMessage.path.toLowerCase()) {\n            case \"speech.hypothesis\":\n            case \"speech.fragment\":\n                const hypothesis: SpeechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\n                const offset: number = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n\n                result = new SpeechRecognitionResult(\n                    this.privRequestSession.requestId,\n                    ResultReason.RecognizingSpeech,\n                    hypothesis.Text,\n                    hypothesis.Duration,\n                    offset,\n                    hypothesis.Language,\n                    hypothesis.LanguageDetectionConfidence,\n                    undefined, // Speaker Id\n                    undefined,\n                    connectionMessage.textBody,\n                    resultProps);\n\n                this.privRequestSession.onHypothesis(offset);\n\n                const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\n\n                if (!!this.privSpeechRecognizer.recognizing) {\n                    try {\n                        this.privSpeechRecognizer.recognizing(this.privSpeechRecognizer, ev);\n                        /* eslint-disable no-empty */\n                    } catch (error) {\n                        // Not going to let errors in the event handler\n                        // trip things up.\n                    }\n                }\n                processed = true;\n                break;\n            case \"speech.phrase\":\n                const simple: SimpleSpeechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n                const resultReason: ResultReason = EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);\n\n                this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + simple.Offset + simple.Duration);\n\n                if (ResultReason.Canceled === resultReason) {\n                    const cancelReason: CancellationReason = EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);\n                    const cancellationErrorCode: CancellationErrorCode = EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);\n\n                    await this.cancelRecognitionLocal(\n                        cancelReason,\n                        cancellationErrorCode,\n                        EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));\n\n                } else {\n                    if (!(this.privRequestSession.isSpeechEnded && resultReason === ResultReason.NoMatch && simple.RecognitionStatus !== RecognitionStatus.InitialSilenceTimeout)) {\n                        if (this.privRecognizerConfig.parameters.getProperty(OutputFormatPropertyName) === OutputFormat[OutputFormat.Simple]) {\n                            result = new SpeechRecognitionResult(\n                                this.privRequestSession.requestId,\n                                resultReason,\n                                simple.DisplayText,\n                                simple.Duration,\n                                simple.Offset + this.privRequestSession.currentTurnAudioOffset,\n                                simple.Language,\n                                simple.LanguageDetectionConfidence,\n                                undefined, // Speaker Id\n                                undefined,\n                                connectionMessage.textBody,\n                                resultProps);\n                        } else {\n                            const detailed: DetailedSpeechPhrase = DetailedSpeechPhrase.fromJSON(connectionMessage.textBody);\n                            const totalOffset: number = detailed.Offset + this.privRequestSession.currentTurnAudioOffset;\n                            const offsetCorrectedJson: string = detailed.getJsonWithCorrectedOffsets(totalOffset);\n\n                            result = new SpeechRecognitionResult(\n                                this.privRequestSession.requestId,\n                                resultReason,\n                                detailed.RecognitionStatus === RecognitionStatus.Success ? detailed.NBest[0].Display : undefined,\n                                detailed.Duration,\n                                totalOffset,\n                                detailed.Language,\n                                detailed.LanguageDetectionConfidence,\n                                undefined, // Speaker Id\n                                undefined,\n                                offsetCorrectedJson,\n                                resultProps);\n                        }\n\n                        const event: SpeechRecognitionEventArgs = new SpeechRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);\n\n                        if (!!this.privSpeechRecognizer.recognized) {\n                            try {\n                                this.privSpeechRecognizer.recognized(this.privSpeechRecognizer, event);\n                                /* eslint-disable no-empty */\n                            } catch (error) {\n                                // Not going to let errors in the event handler\n                                // trip things up.\n                            }\n                        }\n                    }\n\n                    if (!!this.privSuccessCallback) {\n                        try {\n                            this.privSuccessCallback(result);\n                        } catch (e) {\n                            if (!!this.privErrorCallback) {\n                                this.privErrorCallback(e as string);\n                            }\n                        }\n                        // Only invoke the call back once.\n                        // and if it's successful don't invoke the\n                        // error after that.\n                        this.privSuccessCallback = undefined;\n                        this.privErrorCallback = undefined;\n                    }\n                }\n                processed = true;\n                break;\n            default:\n                break;\n        }\n        return processed;\n    }\n\n    // Cancels recognition.\n    protected cancelRecognition(\n        sessionId: string,\n        requestId: string,\n        cancellationReason: CancellationReason,\n        errorCode: CancellationErrorCode,\n        error: string): void {\n\n        const properties: PropertyCollection = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n\n        if (!!this.privSpeechRecognizer.canceled) {\n            const cancelEvent: SpeechRecognitionCanceledEventArgs = new SpeechRecognitionCanceledEventArgs(\n                cancellationReason,\n                error,\n                errorCode,\n                undefined,\n                sessionId);\n            try {\n                this.privSpeechRecognizer.canceled(this.privSpeechRecognizer, cancelEvent);\n                /* eslint-disable no-empty */\n            } catch { }\n        }\n\n        if (!!this.privSuccessCallback) {\n            const result: SpeechRecognitionResult = new SpeechRecognitionResult(\n                requestId,\n                ResultReason.Canceled,\n                undefined, // Text\n                undefined, // Duration\n                undefined, // Offset\n                undefined, // Language\n                undefined, // Language Detection Confidence\n                undefined, // Speaker Id\n                error,\n                undefined, // Json\n                properties);\n            try {\n                this.privSuccessCallback(result);\n                this.privSuccessCallback = undefined;\n                /* eslint-disable no-empty */\n            } catch { }\n        }\n    }\n}\n"]}