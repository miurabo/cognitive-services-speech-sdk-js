{"version":3,"sources":["src/common.speech/SynthesisAdapterBase.ts"],"names":[],"mappings":"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","file":"SynthesisAdapterBase.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nimport {\n    ArgumentNullError,\n    ConnectionClosedEvent,\n    ConnectionEvent,\n    ConnectionMessage,\n    ConnectionState,\n    createNoDashGuid,\n    EventSource,\n    IAudioDestination,\n    IConnection,\n    IDisposable,\n    MessageType,\n    ServiceEvent,\n} from \"../common/Exports\";\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\nimport {\n    CancellationErrorCode,\n    CancellationReason,\n    PropertyCollection,\n    PropertyId,\n    ResultReason,\n    SpeechSynthesisBookmarkEventArgs,\n    SpeechSynthesisEventArgs,\n    SpeechSynthesisResult,\n    SpeechSynthesisVisemeEventArgs,\n    SpeechSynthesisWordBoundaryEventArgs,\n    SpeechSynthesizer,\n} from \"../sdk/Exports\";\nimport {\n    AgentConfig,\n    CancellationErrorCodePropertyName,\n    ISynthesisConnectionFactory,\n    MetadataType,\n    SynthesisAudioMetadata,\n    SynthesisContext,\n    SynthesisTurn,\n    SynthesizerConfig\n} from \"./Exports\";\nimport { AuthInfo, IAuthentication } from \"./IAuthentication\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\n\nexport class SynthesisAdapterBase implements IDisposable {\n    protected privSynthesisTurn: SynthesisTurn;\n    protected privConnectionId: string;\n    protected privSynthesizerConfig: SynthesizerConfig;\n    protected privSpeechSynthesizer: SpeechSynthesizer;\n    protected privSuccessCallback: (e: SpeechSynthesisResult) => void;\n    protected privErrorCallback: (e: string) => void;\n\n    public get synthesisContext(): SynthesisContext {\n        return this.privSynthesisContext;\n    }\n\n    public get agentConfig(): AgentConfig {\n        return this.privAgentConfig;\n    }\n\n    public get connectionEvents(): EventSource<ConnectionEvent> {\n        return this.privConnectionEvents;\n    }\n\n    public get serviceEvents(): EventSource<ServiceEvent> {\n        return this.privServiceEvents;\n    }\n\n    protected speakOverride: (ssml: string, requestId: string, sc: (e: SpeechSynthesisResult) => void, ec: (e: string) => void) => void = undefined;\n\n    // Called when telemetry data is sent to the service.\n    // Used for testing Telemetry capture.\n    public static telemetryData: (json: string) => void;\n    public static telemetryDataEnabled: boolean = true;\n\n    public set activityTemplate(messagePayload: string) {\n        this.privActivityTemplate = messagePayload;\n    }\n    public get activityTemplate(): string {\n        return this.privActivityTemplate;\n    }\n\n    protected receiveMessageOverride: () => void = undefined;\n\n    protected connectImplOverride: (isUnAuthorized: boolean) => void = undefined;\n\n    protected configConnectionOverride: (connection: IConnection) => Promise<IConnection> = undefined;\n\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\n        this.privAudioOutputFormat = format;\n        this.privSynthesisTurn.audioOutputFormat = format;\n        if (this.privSessionAudioDestination !== undefined) {\n            this.privSessionAudioDestination.format = format;\n        }\n        if (this.synthesisContext !== undefined) {\n            this.synthesisContext.audioOutputFormat = format;\n        }\n    }\n    private privAuthentication: IAuthentication;\n    private privConnectionFactory: ISynthesisConnectionFactory;\n\n    // A promise for a configured connection.\n    // Do not consume directly, call fetchConnection instead.\n    private privConnectionConfigurationPromise: Promise<IConnection> = undefined;\n\n    // A promise for a connection, but one that has not had the speech context sent yet.\n    // Do not consume directly, call fetchConnection instead.\n    private privConnectionPromise: Promise<IConnection>;\n    private privAuthFetchEventId: string;\n    private privIsDisposed: boolean;\n    private privConnectionEvents: EventSource<ConnectionEvent>;\n    private privServiceEvents: EventSource<ServiceEvent>;\n    private privSynthesisContext: SynthesisContext;\n    private privAgentConfig: AgentConfig;\n    private privActivityTemplate: string;\n    private privAudioOutputFormat: AudioOutputFormatImpl;\n    private privSessionAudioDestination: IAudioDestination;\n\n    public constructor(\n        authentication: IAuthentication,\n        connectionFactory: ISynthesisConnectionFactory,\n        synthesizerConfig: SynthesizerConfig,\n        speechSynthesizer: SpeechSynthesizer,\n        audioDestination: IAudioDestination) {\n\n        if (!authentication) {\n            throw new ArgumentNullError(\"authentication\");\n        }\n\n        if (!connectionFactory) {\n            throw new ArgumentNullError(\"connectionFactory\");\n        }\n\n        if (!synthesizerConfig) {\n            throw new ArgumentNullError(\"synthesizerConfig\");\n        }\n\n        this.privAuthentication = authentication;\n        this.privConnectionFactory = connectionFactory;\n        this.privSynthesizerConfig = synthesizerConfig;\n        this.privIsDisposed = false;\n        this.privSpeechSynthesizer = speechSynthesizer;\n        this.privSessionAudioDestination = audioDestination;\n        this.privSynthesisTurn = new SynthesisTurn();\n        this.privConnectionEvents = new EventSource<ConnectionEvent>();\n        this.privServiceEvents = new EventSource<ServiceEvent>();\n        this.privSynthesisContext = new SynthesisContext(this.privSpeechSynthesizer);\n        this.privAgentConfig = new AgentConfig();\n\n        this.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\n                const connectionClosedEvent = connectionEvent as ConnectionClosedEvent;\n                if (connectionClosedEvent.statusCode !== 1000) {\n                    this.cancelSynthesisLocal(CancellationReason.Error,\n                        connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure,\n                        `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);\n                }\n            }\n        });\n    }\n\n    public static addHeader(audio: ArrayBuffer, format: AudioOutputFormatImpl): ArrayBuffer {\n        if (!format.hasHeader) {\n            return audio;\n        }\n        format.updateHeader(audio.byteLength);\n        const tmp = new Uint8Array(audio.byteLength + format.header.byteLength);\n        tmp.set(new Uint8Array(format.header), 0);\n        tmp.set(new Uint8Array(audio), format.header.byteLength);\n        return tmp.buffer;\n    }\n\n    public isDisposed(): boolean {\n        return this.privIsDisposed;\n    }\n\n    public async dispose(reason?: string): Promise<void> {\n        this.privIsDisposed = true;\n        if (this.privSessionAudioDestination !== undefined) {\n            this.privSessionAudioDestination.close();\n        }\n        if (this.privConnectionConfigurationPromise !== undefined) {\n            const connection: IConnection = await this.privConnectionConfigurationPromise;\n            await connection.dispose(reason);\n        }\n    }\n\n    public async connect(): Promise<void> {\n        await this.connectImpl();\n    }\n\n    public async sendNetworkMessage(path: string, payload: string | ArrayBuffer): Promise<void> {\n        const type: MessageType = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\n        const contentType: string = typeof payload === \"string\" ? \"application/json\" : \"\";\n\n        const connection: IConnection = await this.fetchConnection();\n        return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\n    }\n\n    public async Speak(\n        text: string,\n        isSSML: boolean,\n        requestId: string,\n        successCallback: (e: SpeechSynthesisResult) => void,\n        errorCallBack: (e: string) => void,\n        audioDestination: IAudioDestination,\n    ): Promise<void> {\n\n        let ssml: string;\n\n        if (isSSML) {\n            ssml = text;\n        } else {\n            ssml = this.privSpeechSynthesizer.buildSsml(text);\n        }\n\n        if (this.speakOverride !== undefined) {\n            return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\n        }\n\n        this.privSuccessCallback = successCallback;\n        this.privErrorCallback = errorCallBack;\n\n        this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\n\n        try {\n            await this.connectImpl();\n            const connection: IConnection = await this.fetchConnection();\n            await this.sendSynthesisContext(connection);\n            await this.sendSsmlMessage(connection, ssml, requestId);\n            const synthesisStartEventArgs: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\n                new SpeechSynthesisResult(\n                    requestId,\n                    ResultReason.SynthesizingAudioStarted,\n                )\n            );\n\n            if (!!this.privSpeechSynthesizer.synthesisStarted) {\n                this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);\n            }\n\n            void this.receiveMessage();\n        } catch (e) {\n            this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e as string);\n            return Promise.reject(e);\n        }\n    }\n\n    // Cancels synthesis.\n    protected cancelSynthesis(\n        requestId: string,\n        cancellationReason: CancellationReason,\n        errorCode: CancellationErrorCode,\n        error: string): void {\n        const properties: PropertyCollection = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n        const result: SpeechSynthesisResult = new SpeechSynthesisResult(\n            requestId,\n            ResultReason.Canceled,\n            undefined,\n            error,\n            properties\n        );\n\n        if (!!this.privSpeechSynthesizer.SynthesisCanceled) {\n            const cancelEvent: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(result);\n            try {\n                this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);\n                /* eslint-disable no-empty */\n            } catch { }\n        }\n\n        if (!!this.privSuccessCallback) {\n            try {\n                this.privSuccessCallback(result);\n                /* eslint-disable no-empty */\n            } catch { }\n        }\n    }\n\n    // Cancels synthesis.\n    protected cancelSynthesisLocal(\n        cancellationReason: CancellationReason,\n        errorCode: CancellationErrorCode,\n        error: string): void {\n\n        if (!!this.privSynthesisTurn.isSynthesizing) {\n            this.privSynthesisTurn.onStopSynthesizing();\n\n            this.cancelSynthesis(\n                this.privSynthesisTurn.requestId,\n                cancellationReason,\n                errorCode,\n                error);\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    protected processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): boolean {\n        return true;\n    }\n\n    protected async receiveMessage(): Promise<void> {\n        try {\n            const connection: IConnection = await this.fetchConnection();\n            const message: ConnectionMessage = await connection.read();\n\n            if (this.receiveMessageOverride !== undefined) {\n                return this.receiveMessageOverride();\n            }\n            if (this.privIsDisposed) {\n                // We're done.\n                return;\n            }\n\n            // indicates we are draining the queue and it came with no message;\n            if (!message) {\n                if (!this.privSynthesisTurn.isSynthesizing) {\n                    return;\n                } else {\n                    return this.receiveMessage();\n                }\n            }\n\n\n            const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n\n            if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\n                switch (connectionMessage.path.toLowerCase()) {\n                    case \"turn.start\":\n                        this.privSynthesisTurn.onServiceTurnStartResponse();\n                        break;\n                    case \"response\":\n                        this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\n                        break;\n                    case \"audio\":\n                        if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase()\n                            && !!connectionMessage.binaryBody) {\n                            this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\n                            if (!!this.privSpeechSynthesizer.synthesizing) {\n                                try {\n                                    const audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat);\n                                    const ev: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\n                                        new SpeechSynthesisResult(\n                                            this.privSynthesisTurn.requestId,\n                                            ResultReason.SynthesizingAudio,\n                                            audioWithHeader));\n                                    this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);\n                                } catch (error) {\n                                    // Not going to let errors in the event handler\n                                    // trip things up.\n                                }\n                            }\n                            if (this.privSessionAudioDestination !== undefined) {\n                                this.privSessionAudioDestination.write(connectionMessage.binaryBody);\n                            }\n                        }\n                        break;\n                    case \"audio.metadata\":\n                        const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\n                        for (const metadata of metadataList) {\n                            switch (metadata.Type) {\n                                case MetadataType.WordBoundary:\n                                case MetadataType.SentenceBoundary:\n                                    this.privSynthesisTurn.onTextBoundaryEvent(metadata);\n\n                                    const wordBoundaryEventArgs: SpeechSynthesisWordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(\n                                        metadata.Data.Offset,\n                                        metadata.Data.Duration,\n                                        metadata.Data.text.Text,\n                                        metadata.Data.text.Length,\n                                        metadata.Type === MetadataType.WordBoundary\n                                            ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset,\n                                        metadata.Data.text.BoundaryType);\n\n                                    if (!!this.privSpeechSynthesizer.wordBoundary) {\n                                        try {\n                                            this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);\n                                        } catch (error) {\n                                            // Not going to let errors in the event handler\n                                            // trip things up.\n                                        }\n                                    }\n                                    break;\n                                case MetadataType.Bookmark:\n                                    const bookmarkEventArgs: SpeechSynthesisBookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(\n                                        metadata.Data.Offset,\n                                        metadata.Data.Bookmark);\n\n                                    if (!!this.privSpeechSynthesizer.bookmarkReached) {\n                                        try {\n                                            this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);\n                                        } catch (error) {\n                                            // Not going to let errors in the event handler\n                                            // trip things up.\n                                        }\n                                    }\n                                    break;\n                                case MetadataType.Viseme:\n                                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\n                                    if (metadata.Data.IsLastAnimation) {\n                                        const visemeEventArgs: SpeechSynthesisVisemeEventArgs = new SpeechSynthesisVisemeEventArgs(\n                                            metadata.Data.Offset,\n                                            metadata.Data.VisemeId,\n                                            this.privSynthesisTurn.getAndClearVisemeAnimation());\n\n                                        if (!!this.privSpeechSynthesizer.visemeReceived) {\n                                            try {\n                                                this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);\n                                            } catch (error) {\n                                                // Not going to let errors in the event handler\n                                                // trip things up.\n                                            }\n                                        }\n                                    }\n                                    break;\n                                case MetadataType.SessionEnd:\n                                    this.privSynthesisTurn.onSessionEnd(metadata);\n                                    break;\n                            }\n                        }\n                        break;\n                    case \"turn.end\":\n                        this.privSynthesisTurn.onServiceTurnEndResponse();\n                        let result: SpeechSynthesisResult;\n                        try {\n                            const audioBuffer: ArrayBuffer = await this.privSynthesisTurn.getAllReceivedAudioWithHeader();\n                            result = new SpeechSynthesisResult(\n                                this.privSynthesisTurn.requestId,\n                                ResultReason.SynthesizingAudioCompleted,\n                                audioBuffer,\n                                undefined,\n                                undefined,\n                                this.privSynthesisTurn.audioDuration\n                            );\n                            if (!!this.privSuccessCallback) {\n                                this.privSuccessCallback(result);\n                            }\n                        } catch (error) {\n                            if (!!this.privErrorCallback) {\n                                this.privErrorCallback(error as string);\n                            }\n                        }\n                        if (this.privSpeechSynthesizer.synthesisCompleted) {\n                            try {\n                                this.privSpeechSynthesizer.synthesisCompleted(\n                                    this.privSpeechSynthesizer,\n                                    new SpeechSynthesisEventArgs(result)\n                                );\n                            } catch (e) {\n                                // Not going to let errors in the event handler\n                                // trip things up.\n                            }\n                        }\n                        break;\n\n                    default:\n\n                        if (!this.processTypeSpecificMessages(connectionMessage)) {\n                            // here are some messages that the derived class has not processed, dispatch them to connect class\n                            if (!!this.privServiceEvents) {\n                                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                            }\n                        }\n\n                }\n            }\n\n            return this.receiveMessage();\n\n        } catch (e) {\n            // TODO: What goes here?\n        }\n    }\n\n    protected sendSynthesisContext(connection: IConnection): Promise<void> {\n        const synthesisContextJson = this.synthesisContext.toJSON();\n\n        if (synthesisContextJson) {\n            return connection.send(new SpeechConnectionMessage(\n                MessageType.Text,\n                \"synthesis.context\",\n                this.privSynthesisTurn.requestId,\n                \"application/json\",\n                synthesisContextJson));\n        }\n        return;\n    }\n\n    protected connectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\n        if (this.privConnectionPromise != null) {\n            return this.privConnectionPromise.then((connection: IConnection): Promise<IConnection> => {\n                if (connection.state() === ConnectionState.Disconnected) {\n                    this.privConnectionId = null;\n                    this.privConnectionPromise = null;\n                    return this.connectImpl();\n                }\n                return this.privConnectionPromise;\n            }, (): Promise<IConnection> => {\n                this.privConnectionId = null;\n                this.privConnectionPromise = null;\n                return this.connectImpl();\n            });\n        }\n        this.privAuthFetchEventId = createNoDashGuid();\n        this.privConnectionId = createNoDashGuid();\n\n        this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);\n\n        const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\n\n        this.privConnectionPromise = authPromise.then(async (result: AuthInfo): Promise<IConnection> => {\n            this.privSynthesisTurn.onAuthCompleted(false);\n\n            const connection: IConnection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);\n\n            // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n            // it'll stop sending events.\n            connection.events.attach((event: ConnectionEvent): void => {\n                this.connectionEvents.onEvent(event);\n            });\n            const response = await connection.open();\n            if (response.statusCode === 200) {\n                this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n                return Promise.resolve(connection);\n            } else if (response.statusCode === 403 && !isUnAuthorized) {\n                return this.connectImpl(true);\n            } else {\n                this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n                return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\n            }\n        }, (error: string): Promise<IConnection> => {\n            this.privSynthesisTurn.onAuthCompleted(true);\n            throw new Error(error);\n        });\n\n        // Attach an empty handler to allow the promise to run in the background while\n        // other startup events happen. It'll eventually be awaited on.\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        this.privConnectionPromise.catch((): void => { });\n\n        return this.privConnectionPromise;\n    }\n    protected sendSpeechServiceConfig(connection: IConnection, SpeechServiceConfigJson: string): Promise<void> {\n        if (SpeechServiceConfigJson) {\n            return connection.send(new SpeechConnectionMessage(\n                MessageType.Text,\n                \"speech.config\",\n                this.privSynthesisTurn.requestId,\n                \"application/json\",\n                SpeechServiceConfigJson));\n        }\n    }\n\n    protected sendSsmlMessage(connection: IConnection, ssml: string, requestId: string): Promise<void> {\n        return connection.send(new SpeechConnectionMessage(\n            MessageType.Text,\n            \"ssml\",\n            requestId,\n            \"application/ssml+xml\",\n            ssml));\n    }\n\n    private async fetchConnection(): Promise<IConnection> {\n        if (this.privConnectionConfigurationPromise !== undefined) {\n            return this.privConnectionConfigurationPromise.then((connection: IConnection): Promise<IConnection> => {\n                if (connection.state() === ConnectionState.Disconnected) {\n                    this.privConnectionId = null;\n                    this.privConnectionConfigurationPromise = undefined;\n                    return this.fetchConnection();\n                }\n                return this.privConnectionConfigurationPromise;\n            }, (): Promise<IConnection> => {\n                this.privConnectionId = null;\n                this.privConnectionConfigurationPromise = undefined;\n                return this.fetchConnection();\n            });\n        }\n        this.privConnectionConfigurationPromise = this.configureConnection();\n        return await this.privConnectionConfigurationPromise;\n    }\n\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\n    private async configureConnection(): Promise<IConnection> {\n        const connection: IConnection = await this.connectImpl();\n        if (this.configConnectionOverride !== undefined) {\n            return this.configConnectionOverride(connection);\n        }\n        await this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\n        return connection;\n    }\n}\n"]}